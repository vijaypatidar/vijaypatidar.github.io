"use strict";(self.webpackChunkmy_portfolio=self.webpackChunkmy_portfolio||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"spring-boot-vite-react-gradle","metadata":{"permalink":"/blog/spring-boot-vite-react-gradle","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2025-07-20-spring-boot-vite-react-gradle/index.md","source":"@site/blog/2025-07-20-spring-boot-vite-react-gradle/index.md","title":"Clean and Modular: Integrating Spring Boot with Vite + React in a Gradle Project","description":"Learn how to structure a full-stack application by integrating a Vite + React frontend with a Spring Boot backend using Gradle multi-module setup.","date":"2025-07-20T00:00:00.000Z","tags":[{"inline":true,"label":"spring-boot","permalink":"/blog/tags/spring-boot"},{"inline":true,"label":"react","permalink":"/blog/tags/react"},{"inline":true,"label":"gradle","permalink":"/blog/tags/gradle"},{"inline":true,"label":"vite","permalink":"/blog/tags/vite"}],"readingTime":1.74,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"title":"Clean and Modular: Integrating Spring Boot with Vite + React in a Gradle Project","description":"Learn how to structure a full-stack application by integrating a Vite + React frontend with a Spring Boot backend using Gradle multi-module setup.","slug":"spring-boot-vite-react-gradle","authors":["vijay"],"tags":["spring-boot","react","gradle","vite"]},"unlisted":false,"nextItem":{"title":"Create Beautiful Vertical Stepper in React Using MUI + TailwindCSS","permalink":"/blog/vertical-stepper-react-mui-tailwind"}},"content":"## **Clean and Modular: Integrating Spring Boot with Vite + React in a Gradle Project**\\n\\nWhile working on a full-stack Spring Boot application, I needed to develop a React-based frontend and serve it alongside the backend. To streamline the development and build processes, I decided to manage the frontend as a submodule within the same Gradle project using the `gradle-node-plugin`.\\n\\n## \x3c!-- truncate --\x3e\\n\\n## **Setting Up the Frontend with Vite + React**\\n\\nStart by creating a new Vite + React TypeScript project using the following command:\\n\\n```bash\\nnpm create vite@latest frontend -- --template react-ts\\n```\\n\\nThis will scaffold a new frontend project inside a `frontend` directory, which you can place within your existing Gradle project.\\n\\n---\\n\\n## **Registering the Vite Project as a Gradle Submodule**\\n\\n1. **Create a `build.gradle` file inside the `frontend/` directory** and add the following plugins:\\n\\n```groovy\\nplugins {\\n    id \\"com.github.node-gradle.node\\" version \\"7.1.0\\"\\n    id \\"base\\"\\n}\\n```\\n\\n2. **Configure the Node plugin** to download and use a specific Node.js version:\\n\\n```groovy\\nnode {\\n    download = true\\n    version = \\"22.12.0\\"\\n}\\n```\\n\\n3. **Define Gradle tasks** to build, clean, and run the frontend:\\n\\n```groovy\\ntasks.register(\'buildFrontend\', NpxTask) {\\n    dependsOn npmInstall\\n    command = \'npm\'\\n    args = [\'run\', \'build\']\\n}\\n\\ntasks.register(\'devRun\', NpxTask) {\\n    dependsOn npmInstall\\n    command = \'npm\'\\n    args = [\'run\', \'dev\']\\n}\\n\\ntasks.register(\'cleanFrontend\', Delete) {\\n    group = \\"build\\"\\n    description = \\"Cleans the Vite distribution folder\\"\\n    delete file(\\"dist\\")\\n}\\n\\ntasks.clean.dependsOn cleanFrontend\\ntasks.build.dependsOn buildFrontend\\n```\\n\\n---\\n\\n## **Include Frontend as a Submodule in Root Gradle Project**\\n\\nUpdate your `settings.gradle` file to register both modules:\\n\\n```groovy\\nrootProject.name = \'fullstack-spring-vite\'\\n\\ninclude \'frontend\'\\ninclude \'backend\'\\n```\\n\\n---\\n\\n## **Serve Frontend from Spring Boot**\\n\\nModify your backend\u2019s `build.gradle` (or `build.gradle.kts`) to package the frontend static files:\\n\\n```groovy\\nbootJar {\\n    dependsOn \':frontend:build\'\\n    from(\\"../frontend/dist\\") {\\n        into \\"BOOT-INF/classes/static\\"\\n    }\\n}\\n\\ntasks.clean.dependsOn \':frontend:clean\'\\ntasks.build.dependsOn \':frontend:build\'\\n```\\n\\nNow, whenever you build the backend, it will automatically build the frontend and embed the static files into the Spring Boot JAR under the `/static` directory.\\n\\n---\\n\\n## **Building the Project**\\n\\nTo build the entire project:\\n\\n```bash\\n./gradlew clean build\\n```\\n\\nThis will compile both backend and frontend, and the final Spring Boot JAR will include your frontend assets, ready to be served.\\n\\n---\\n\\n\ud83d\udd17 **You can find the complete source code on [my GitHub repository](https://github.com/vijaypatidar/fullstack-spring-vite)**"},{"id":"vertical-stepper-react-mui-tailwind","metadata":{"permalink":"/blog/vertical-stepper-react-mui-tailwind","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2025-05-16-vertical-stepper-react-mui-tailwind/index.md","source":"@site/blog/2025-05-16-vertical-stepper-react-mui-tailwind/index.md","title":"Create Beautiful Vertical Stepper in React Using MUI + TailwindCSS","description":"Learn how to build a customizable and beautiful vertical stepper component in React with Material UI and Tailwind CSS.","date":"2025-05-16T00:00:00.000Z","tags":[{"inline":true,"label":"react","permalink":"/blog/tags/react"},{"inline":true,"label":"typescript","permalink":"/blog/tags/typescript"}],"readingTime":2.37,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"title":"Create Beautiful Vertical Stepper in React Using MUI + TailwindCSS","description":"Learn how to build a customizable and beautiful vertical stepper component in React with Material UI and Tailwind CSS.","slug":"vertical-stepper-react-mui-tailwind","authors":["vijay"],"tags":["react","typescript"]},"unlisted":false,"prevItem":{"title":"Clean and Modular: Integrating Spring Boot with Vite + React in a Gradle Project","permalink":"/blog/spring-boot-vite-react-gradle"},"nextItem":{"title":"Setup ANTLR in Java Project and Write Grammar for Parsing Boolean Algebra Expressions","permalink":"/blog/setup-antlr-java-boolean-grammar"}},"content":"In this post, we\u2019ll walk through how to create a visually appealing **vertical stepper component** in React using [Material UI (MUI)](https://mui.com/) and [Tailwind CSS](https://tailwindcss.com/). This component is fully customizable and comes with gradient connectors, icons, and styled content boxes.\\n\\n## ![Verticle Stepper](./verticle-stepper-image.png)\\n\\n\x3c!-- truncate --\x3e\\n\\n## \ud83c\udfaf Goal\\n\\nWe\'ll build a `VerticleStepper` component that:\\n\\n- Uses MUI\u2019s `Stepper`, `Step`, and `StepLabel`.\\n- Has a custom connector and step icon.\\n- Works with Tailwind for enhanced styling.\\n- Is reusable and accepts steps and active state as props.\\n\\n---\\n\\n## \ud83e\uddf1 Step 1: Build the Component\\n\\nCreate a `VerticleStepper.tsx` file and paste the following code:\\n\\n```tsx\\nimport React from \\"react\\";\\nimport Stepper from \\"@mui/material/Stepper\\";\\nimport Step from \\"@mui/material/Step\\";\\nimport StepLabel from \\"@mui/material/StepLabel\\";\\nimport {\\n  StepConnector,\\n  stepConnectorClasses,\\n  StepContent,\\n  styled,\\n  Typography,\\n  type StepIconProps,\\n} from \\"@mui/material\\";\\nimport { Clock, TickCircle } from \\"iconsax-reactjs\\";\\n\\nexport interface VerticleStepperStep {\\n  label: string;\\n  content: React.JSX.Element;\\n}\\nexport interface VerticleStepperProps {\\n  steps: VerticleStepperStep[];\\n  activeStep: number;\\n}\\n\\n// Custom connector with gradient style\\nconst ColorlibConnector = styled(StepConnector)(({ theme }) => ({\\n  [`&.${stepConnectorClasses.alternativeLabel}`]: {\\n    top: 22,\\n  },\\n  [`&.${stepConnectorClasses.active}, &.${stepConnectorClasses.completed}`]: {\\n    [`& .${stepConnectorClasses.line}`]: {\\n      backgroundImage:\\n        \\"linear-gradient( 95deg, rgb(242,113,33) 0%, rgb(233,64,87) 50%, rgb(138,35,135) 100%)\\",\\n    },\\n  },\\n  [`& .${stepConnectorClasses.line}`]: {\\n    height: 36,\\n    border: 0,\\n    width: 1,\\n    marginLeft: 8,\\n    marginTop: -8,\\n    marginBottom: -8,\\n    backgroundColor: \\"#bdbdbd\\",\\n    ...theme.applyStyles(\\"dark\\", {\\n      backgroundColor: theme.palette.grey[800],\\n    }),\\n  },\\n}));\\n\\n// Custom step icon\\nconst ColorlibStepIconRoot = styled(\\"div\\")<{\\n  ownerState: { completed?: boolean; active?: boolean };\\n}>(({ theme }) => ({\\n  backgroundColor: \\"#ccc\\",\\n  zIndex: 1,\\n  color: \\"#fff\\",\\n  width: 40,\\n  height: 40,\\n  display: \\"flex\\",\\n  borderRadius: \\"50%\\",\\n  justifyContent: \\"center\\",\\n  alignItems: \\"center\\",\\n  ...theme.applyStyles(\\"dark\\", {\\n    backgroundColor: theme.palette.grey[700],\\n  }),\\n  variants: [\\n    {\\n      props: ({ ownerState }) => ownerState.active,\\n      style: {\\n        backgroundImage:\\n          \\"linear-gradient( 136deg, rgb(242,113,33) 0%, rgb(233,64,87) 50%, rgb(138,35,135) 100%)\\",\\n        boxShadow: \\"0 4px 10px 0 rgba(0,0,0,.25)\\",\\n      },\\n    },\\n    {\\n      props: ({ ownerState }) => ownerState.completed,\\n      style: {\\n        backgroundImage:\\n          \\"linear-gradient( 136deg, rgb(242,113,33) 0%, rgb(233,64,87) 50%, rgb(138,35,135) 100%)\\",\\n      },\\n    },\\n  ],\\n}));\\n\\nfunction ColorlibStepIcon(props: StepIconProps) {\\n  const { active, completed, className } = props;\\n\\n  return (\\n    <ColorlibStepIconRoot\\n      ownerState={{ completed, active }}\\n      className={className}\\n    >\\n      {active ? <Clock size={25} /> : <TickCircle size={25} />}\\n    </ColorlibStepIconRoot>\\n  );\\n}\\n\\n// Final component\\nexport const VerticleStepper = ({\\n  steps,\\n  activeStep,\\n}: VerticleStepperProps) => {\\n  return (\\n    <Stepper\\n      activeStep={activeStep}\\n      orientation=\\"vertical\\"\\n      connector={<ColorlibConnector />}\\n    >\\n      {steps.map(({ label, content }) => (\\n        <Step key={label}>\\n          <StepLabel StepIconComponent={ColorlibStepIcon}>\\n            <Typography className=\\"text-white\\">{label}</Typography>\\n          </StepLabel>\\n          <StepContent style={{ marginLeft: 20, marginTop: \\"-8px\\" }}>\\n            <div className=\\"border-1 rounded-2xl p-2.5 border-[rgb(242,113,33)] border-r-[rgb(260,119,33)] border-b-[rgb(210,90,33)]\\">\\n              {content}\\n            </div>\\n          </StepContent>\\n        </Step>\\n      ))}\\n    </Stepper>\\n  );\\n};\\n```\\n\\n---\\n\\n## \u2699\ufe0f Step 2: Use the Component\\n\\nYou can now import and use the `VerticleStepper` in your main page or any component:\\n\\n```tsx\\nimport React from \\"react\\";\\nimport { VerticleStepper } from \\"./VerticleStepper\\";\\nimport { Button } from \\"@mui/material\\";\\n\\nexport default function Home() {\\n  const [active, setActive] = React.useState(0);\\n\\n  return (\\n    <VerticleStepper\\n      activeStep={active}\\n      steps={[\\n        \\"Introduction\\",\\n        \\"Index\\",\\n        \\"Table of Contents\\",\\n        \\"Chapter 1\\",\\n        \\"Chapter 2\\",\\n        \\"Chapter 3\\",\\n        \\"Chapter 4\\",\\n        \\"Chapter 5\\",\\n        \\"Chapter 6\\",\\n      ].map((step) => ({\\n        label: step,\\n        content: (\\n          <div>\\n            <div className=\\"m-3\\">Content for the &apos;{step}&apos; step</div>\\n            <div>\\n              {active !== 0 && (\\n                <Button onClick={() => setActive((s) => s - 1)}>Prev</Button>\\n              )}\\n              {active < 8 && (\\n                <Button onClick={() => setActive((s) => s + 1)}>Next</Button>\\n              )}\\n            </div>\\n          </div>\\n        ),\\n      }))}\\n    />\\n  );\\n}\\n```"},{"id":"setup-antlr-java-boolean-grammar","metadata":{"permalink":"/blog/setup-antlr-java-boolean-grammar","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2025-05-14-setup-antlr-java-boolean-grammar/index.md","source":"@site/blog/2025-05-14-setup-antlr-java-boolean-grammar/index.md","title":"Setup ANTLR in Java Project and Write Grammar for Parsing Boolean Algebra Expressions","description":"Learn how to set up ANTLR in a Java project using Gradle and create a custom grammar to parse Boolean algebra expressions.","date":"2025-05-14T00:00:00.000Z","tags":[{"inline":true,"label":"antlr","permalink":"/blog/tags/antlr"},{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"Java"}],"readingTime":1.64,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"title":"Setup ANTLR in Java Project and Write Grammar for Parsing Boolean Algebra Expressions","description":"Learn how to set up ANTLR in a Java project using Gradle and create a custom grammar to parse Boolean algebra expressions.","slug":"setup-antlr-java-boolean-grammar","authors":["vijay"],"tags":["antlr","java"]},"unlisted":false,"prevItem":{"title":"Create Beautiful Vertical Stepper in React Using MUI + TailwindCSS","permalink":"/blog/vertical-stepper-react-mui-tailwind"},"nextItem":{"title":"Setup flyway migration with spring boot","permalink":"/blog/2025-02-10-Setup-flyway-migration-with-spring-boot"}},"content":"ANTLR (Another Tool for Language Recognition) is a powerful parser generator used for reading, processing, and executing or translating structured text or binary files. In this post, you\'ll learn how to:\\n\\n- Set up ANTLR in a Java project using Gradle.\\n- Write a grammar for parsing Boolean algebra expressions.\\n- Generate lexer and parser code using the Gradle plugin.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Step 1: Add ANTLR Plugin to `build.gradle`\\n\\nFirst, apply the ANTLR plugin and add required dependencies.\\n\\n```groovy\\nplugins {\\n    id \'java\'\\n    id \'antlr\'\\n}\\n\\ngroup = \'com.vkpapps\'\\nversion = \'1.0-SNAPSHOT\'\\n\\nrepositories {\\n    mavenCentral()\\n}\\n\\ndependencies {\\n    antlr \\"org.antlr:antlr4:4.13.1\\"\\n    implementation \\"org.antlr:antlr4-runtime:4.13.1\\"\\n    // other dependencies\\n}\\n\\ngenerateGrammarSource {\\n    maxHeapSize = \\"64m\\"\\n    arguments += [\\"-visitor\\", \\"-long-messages\\"]\\n    outputDirectory = file(\\"build/generated/antlr/main/com/vkpapps\\")\\n}\\n\\nsourceSets {\\n    main {\\n        java {\\n            srcDir \\"$buildDir/generated/antlr/main\\"\\n        }\\n        antlr {\\n            srcDirs = [\'src/main/antlr\']\\n        }\\n    }\\n}\\n```\\n\\nThis config tells Gradle to:\\n\\n- Use ANTLR for grammar processing.\\n- Output generated sources in a specific directory.\\n- Include those sources in the main source set.\\n\\n## Step 2: Create ANTLR Grammar Directory\\n\\nCreate a folder named `antlr` under `src/main` to store your grammar files:\\n\\n```\\nsrc/\\n\u2514\u2500\u2500 main/\\n    \u2514\u2500\u2500 antlr/\\n        \u2514\u2500\u2500 BooleanAlgebra.g4\\n```\\n\\n## Step 3: Define the Boolean Algebra Grammar\\n\\nCreate a file named `BooleanAlgebra.g4` and define your grammar:\\n\\n```antlr\\ngrammar BooleanAlgebra;\\n\\n@header {\\npackage com.vkpapps;\\n}\\n\\nexpr\\n    : expr (OPERATION expr)+\\n    | \'{\' expr \'}\'\\n    | \'[\' expr \']\'\\n    | \'(\' expr \')\'\\n    | VARIABLE\\n    | (VARIABLE)? \'(\' expr \')\' (VARIABLE)?\\n    | WS\\n    ;\\n\\nVARIABLE\\n    : [a-z]+\\n    | [a-z]+\'\\\\\'\' (WS)*\\n    | [0-1]\\n    ;\\n\\nOPERATION\\n    : OR\\n    | PRODUCT\\n    ;\\n\\nOR      : \'OR\' | \'or\' | \'+\' ;\\nPRODUCT : \'*\' ;\\n\\nWS : [\\\\t\\\\r\\\\n]+ -> skip ;\\n```\\n\\nThis grammar handles:\\n\\n- Parentheses and brackets\\n- Single-letter variables (like `a`, `b\'`)\\n- Basic operations (`+`, `*`, `OR`, etc.)\\n\\n## Step 4: Generate Parser and Lexer Code\\n\\nUse the following Gradle command to generate the parser and lexer classes:\\n\\n```bash\\n./gradlew generateGrammarSource\\n```\\n\\nThis will generate Java classes for the lexer, parser, and visitor pattern under `build/generated/antlr/main/com/vkpapps`.\\n\\n## What\'s Next?\\n\\nWith the parser and lexer in place, you can now write a Java program to:\\n\\n- Parse Boolean expressions.\\n- Traverse the parse tree using the generated visitor classes.\\n- Evaluate or transform expressions for your specific use case (e.g., simplification, circuit generation, etc.)"},{"id":"2025-02-10-Setup-flyway-migration-with-spring-boot","metadata":{"permalink":"/blog/2025-02-10-Setup-flyway-migration-with-spring-boot","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2025-02-10-Setup-flyway-migration-with-spring-boot/index.md","source":"@site/blog/2025-02-10-Setup-flyway-migration-with-spring-boot/index.md","title":"Setup flyway migration with spring boot","description":"Database migrations are essential for maintaining consistency and version control in applications. Flyway is a popular database migration tool that integrates seamlessly with Spring Boot. In this guide, we will set up Flyway in a Spring Boot application and configure it for different environments.","date":"2025-02-10T00:00:00.000Z","tags":[{"inline":true,"label":"flyway","permalink":"/blog/tags/flyway"},{"inline":false,"label":"Spring","permalink":"/blog/tags/spring","description":"Spring Boot"}],"readingTime":1.96,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"2025-02-10-Setup-flyway-migration-with-spring-boot","title":"Setup flyway migration with spring boot","authors":["vijay"],"tags":["flyway","spring"]},"unlisted":false,"prevItem":{"title":"Setup ANTLR in Java Project and Write Grammar for Parsing Boolean Algebra Expressions","permalink":"/blog/setup-antlr-java-boolean-grammar"},"nextItem":{"title":"Publish Android App Bundle to Play Store Using GitHub Actions","permalink":"/blog/publish-android-app-bundle-to-play-store-using-github-actions"}},"content":"Database migrations are essential for maintaining consistency and version control in applications. Flyway is a popular database migration tool that integrates seamlessly with Spring Boot. In this guide, we will set up Flyway in a Spring Boot application and configure it for different environments.\\n\\n---\\n\\n## Step 1: Add Flyway Dependencies in Gradle\\n\\nThe first step is to update your `build.gradle` file to include the Flyway dependencies.\\n\\n\x3c!-- truncate --\x3e\\n\\n```gradle\\nplugins {\\n\\t...\\n}\\n\\ngroup = \'com.vkpapps\'\\nversion = \'0.0.1-SNAPSHOT\'\\n\\njava {\\n\\ttoolchain {\\n\\t\\tlanguageVersion = JavaLanguageVersion.of(21)\\n\\t}\\n}\\n\\nconfigurations {\\n\\tcompileOnly {\\n\\t\\textendsFrom annotationProcessor\\n\\t}\\n}\\n\\nrepositories {\\n\\tmavenCentral()\\n}\\n\\ndependencies {\\n  // Other dependencies\\n\\timplementation \'org.flywaydb:flyway-core\'\\n\\timplementation \'org.flywaydb:flyway-database-postgresql\'\\n}\\n```\\n\\n---\\n\\n## Step 2: Configure Database Connection in `application.yaml`\\n\\nNext, we configure the database connection and enable Flyway in `application.yaml`:\\n\\n```yml\\nspring:\\n  application:\\n    name: flyway-migration-example\\n  jackson:\\n    property-naming-strategy: SNAKE_CASE\\n  datasource:\\n    driver-class-name: org.postgresql.Driver\\n    url: jdbc:postgresql://localhost:5432/postgres?currentSchema=flyway-migration-example\\n    username: vijay\\n    password:\\n  jpa:\\n    database-platform: org.hibernate.dialect.PostgreSQLDialect\\n    hibernate:\\n      ddl-auto: none\\n    properties:\\n      hibernate:\\n        format_sql: true\\n        show_sql: true\\n  flyway:\\n    baseline-on-migrate: true\\n    enabled: true\\n    locations: classpath:db/migration/common,classpath:db/migration/local\\n```\\n\\n---\\n\\n## Step 3: Organizing Migration Scripts Based on Environment\\n\\nFlyway allows organizing migration scripts into different folders and applying them based on the environment. We configure `locations` accordingly.\\n\\n### Local Environment\\n\\nIn the local environment, we also run an insert script to seed the database with dummy data:\\n\\n```properties\\nspring:\\n  datasource:\\n    driver-class-name: org.postgresql.Driver\\n    url: jdbc:postgresql://localhost:5432/postgres?currentSchema=flyway-migration-example\\n    username: vijay\\n    password:\\n  jpa:\\n    database-platform: org.hibernate.dialect.PostgreSQLDialect\\n    hibernate:\\n      ddl-auto: update  # or \\"none\\" if schema is managed manually\\n    properties:\\n      hibernate:\\n        format_sql: true\\n        show_sql: true\\n  flyway:\\n    baseline-on-migrate: true\\n    enabled: true\\n    locations: classpath:db/migration/common,classpath:db/migration/local\\n```\\n\\n### Production Environment\\n\\nIn production, we only run the common database migration scripts and avoid inserting dummy data:\\n\\n```properties\\nspring:\\n  datasource:\\n    driver-class-name: org.postgresql.Driver\\n    url: jdbc:postgresql://localhost:5432/postgres?currentSchema=flyway-migration-example\\n    username: vijay\\n    password:\\n  jpa:\\n    database-platform: org.hibernate.dialect.PostgreSQLDialect\\n    hibernate:\\n      ddl-auto: none\\n    properties:\\n      hibernate:\\n        format_sql: true\\n        show_sql: true\\n  flyway:\\n    baseline-on-migrate: true\\n    enabled: true\\n    locations: classpath:db/migration/common\\n```\\n\\n---\\n\\n## Conclusion\\n\\nSetting up Flyway in a Spring Boot application ensures seamless database migrations while maintaining version control. By structuring migrations based on environments, we can manage schema changes efficiently without affecting production stability.\\n\\nNow that your Flyway setup is complete, you can start adding migration scripts in `db/migration/common` and `db/migration/local` folders to control database schema changes. Happy coding!"},{"id":"publish-android-app-bundle-to-play-store-using-github-actions","metadata":{"permalink":"/blog/publish-android-app-bundle-to-play-store-using-github-actions","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2025-01-08-publish-android-app-bundle-to-play-store-using-github-actions/index.md","source":"@site/blog/2025-01-08-publish-android-app-bundle-to-play-store-using-github-actions/index.md","title":"Publish Android App Bundle to Play Store Using GitHub Actions","description":"Publishing your Android app bundle to the Google Play Store can be streamlined by automating the process with GitHub Actions. In this guide, we\u2019ll walk you through the steps to set up a CI/CD pipeline that builds, signs, and uploads your app to the Play Store.","date":"2025-01-08T00:00:00.000Z","tags":[{"inline":false,"label":"CI/CD","permalink":"/blog/tags/cicd","description":"CI/CD Pileline"},{"inline":false,"label":"Github Action","permalink":"/blog/tags/github-action","description":"Github Action CI/CD"}],"readingTime":2.19,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"publish-android-app-bundle-to-play-store-using-github-actions","title":"Publish Android App Bundle to Play Store Using GitHub Actions","authors":["vijay"],"tags":["cicd","github-action"]},"unlisted":false,"prevItem":{"title":"Setup flyway migration with spring boot","permalink":"/blog/2025-02-10-Setup-flyway-migration-with-spring-boot"},"nextItem":{"title":"How to Create Entity Classes for Relational Tables","permalink":"/blog/how-to-create-entity-classes-for-relational-tables"}},"content":"Publishing your Android app bundle to the Google Play Store can be streamlined by automating the process with GitHub Actions. In this guide, we\u2019ll walk you through the steps to set up a CI/CD pipeline that builds, signs, and uploads your app to the Play Store.\\n\\n---\\n\\n## Step 1: Configure Gradle for Signing\\n\\nThe first step is to update your `build.gradle.kts` file to include the signing configuration. This setup ensures that the app is signed with the correct credentials during the build process.\\n\\n\\n\x3c!-- truncate --\x3e\\n\\n```kotlin\\nplugins {\\n    alias(libs.plugins.android.application)\\n    alias(libs.plugins.kotlin.android)\\n    id(\\"com.google.gms.google-services\\")\\n}\\n\\nandroid {\\n    namespace = \\"com.vkpapps.booleanalgebra\\"\\n    compileSdk = 35\\n\\n    defaultConfig {\\n        ...\\n    }\\n    signingConfigs {\\n        create(\\"release\\") {\\n            storeFile = file(\\"./../boolean-algebra.jks\\")\\n            storePassword = System.getenv(\\"BOOLEAN_ALGEBRA_SIGN_STORE_PASSWORD\\")\\n            keyAlias = System.getenv(\\"BOOLEAN_ALGEBRA_SIGN_KEY_ALIAS\\")\\n            keyPassword = System.getenv(\\"BOOLEAN_ALGEBRA_SIGN_KEY_PASSWORD\\")\\n        }\\n    }\\n\\n    buildTypes {\\n        release {\\n            isMinifyEnabled = true\\n            isShrinkResources = true\\n            signingConfig = signingConfigs.getByName(\\"release\\")\\n            isDebuggable = false\\n            proguardFiles(\\n                getDefaultProguardFile(\\"proguard-android-optimize.txt\\"),\\n                \\"proguard-rules.pro\\"\\n            )\\n        }\\n\\n        ...\\n    }\\n    ...\\n}\\n\\ndependencies {\\n    ...\\n}\\n```\\n\\nEnsure the signing keys and passwords are stored as environment variables or GitHub secrets for security.\\n\\n---\\n\\n## Step 2: Create a GitHub Actions Workflow\\n\\nCreate a GitHub Actions workflow file in your repository\u2019s `.github/workflows` directory. Name it `android-ci.yml` or a similar descriptive name.\\n\\n```yaml\\nname: Android CI\\n\\non:\\n  push:\\n    branches:\\n      - main\\n\\njobs:\\n  build:\\n\\n    runs-on: ubuntu-latest\\n\\n    steps:\\n      - name: Checkout code\\n        uses: actions/checkout@v3\\n\\n      - name: Set up JDK 21\\n        uses: actions/setup-java@v3\\n        with:\\n          java-version: \'17\'\\n          distribution: \'corretto\'\\n\\n      - name: Grant permissions for gradlew\\n        run: chmod +x gradlew\\n\\n      - name: Set environment variables\\n        run: |\\n          echo \\"BOOLEAN_ALGEBRA_SIGN_STORE_PASSWORD=${{ secrets.BOOLEAN_ALGEBRA_SIGN_STORE_PASSWORD }}\\" >> $GITHUB_ENV\\n          echo \\"BOOLEAN_ALGEBRA_SIGN_KEY_ALIAS=${{ secrets.BOOLEAN_ALGEBRA_SIGN_KEY_ALIAS }}\\" >> $GITHUB_ENV\\n          echo \\"BOOLEAN_ALGEBRA_SIGN_KEY_PASSWORD=${{ secrets.BOOLEAN_ALGEBRA_SIGN_KEY_PASSWORD }}\\" >> $GITHUB_ENV\\n\\n      - name: Run unit tests\\n        run: ./gradlew test\\n\\n      - name: Run Lint\\n        run: ./gradlew lint\\n\\n      - name: Assemble Release\\n        run: ./gradlew bundleRelease\\n\\n      - name: Publish to Play Store\\n        uses: r0adkll/upload-google-play@v1\\n        with:\\n          serviceAccountJsonPlainText: ${{ secrets.GOOGLE_PLAY_CREDENTIALS }}\\n          packageName: com.vkpapps.booleanalgebra\\n          releaseFiles: app/build/outputs/bundle/release/app-release.aab\\n          track: beta\\n          status: \'completed\'\\n```\\n\\nThis workflow builds the app, runs tests, and uploads the release bundle to the Play Store.\\n\\n---\\n\\n## Step 3: Add GitHub Secrets\\n\\nThe workflow depends on several secrets to securely manage sensitive information. Add the following secrets to your GitHub repository:\\n\\n1. **BOOLEAN_ALGEBRA_SIGN_STORE_PASSWORD**: Password for your keystore file.\\n2. **BOOLEAN_ALGEBRA_SIGN_KEY_ALIAS**: Alias for your signing key.\\n3. **BOOLEAN_ALGEBRA_SIGN_KEY_PASSWORD**: Password for your signing key.\\n4. **GOOGLE_PLAY_CREDENTIALS**: JSON key for your Google Play Service Account.\\n\\nTo add secrets:\\n1. Go to your GitHub repository.\\n2. Navigate to **Settings** > **Secrets and variables** > **Actions**.\\n3. Click **New repository secret** and add each of the secrets listed above.\\n\\n---\\n\\n## Conclusion\\n\\nBy following these steps, you\u2019ve successfully automated the publishing process for your Android app using GitHub Actions. This setup not only saves time but also ensures consistency and reliability in your CI/CD pipeline.\\n\\nFeel free to customize the workflow based on your project\u2019s specific needs. Happy coding!"},{"id":"how-to-create-entity-classes-for-relational-tables","metadata":{"permalink":"/blog/how-to-create-entity-classes-for-relational-tables","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2024-12-07-how-to-create-entity-classes-for-relational-tables/index.md","source":"@site/blog/2024-12-07-how-to-create-entity-classes-for-relational-tables/index.md","title":"How to Create Entity Classes for Relational Tables","description":"How to Create Entity Classes for Relational Tables","date":"2024-12-07T00:00:00.000Z","tags":[{"inline":false,"label":"JPA","permalink":"/blog/tags/jpa","description":"Java Persistence API"},{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"Java"}],"readingTime":2.77,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"how-to-create-entity-classes-for-relational-tables","title":"How to Create Entity Classes for Relational Tables","authors":["vijay"],"tags":["jpa","java"]},"unlisted":false,"prevItem":{"title":"Publish Android App Bundle to Play Store Using GitHub Actions","permalink":"/blog/publish-android-app-bundle-to-play-store-using-github-actions"},"nextItem":{"title":"What is Spring Boot Starter","permalink":"/blog/what-is-spring-boot-starters"}},"content":"## **How to Create Entity Classes for Relational Tables**\\n\\nWhen working with Java Persistence API (JPA), defining entity classes is a critical step to map relational database tables to Java objects. In this post, we\u2019ll explore how to create entity classes for a relational schema, focusing on best practices and solving common challenges such as composite keys.\\n\\n\x3c!-- truncate --\x3e\\n\\n---\\n\\n\\n## **Schema Overview**\\n\\nConsider the following relational database schema:\\n\\n- **Users** (`id`, `name`, `email`)\\n- **Posts** (`id`, `user_id`, `title`, `content`, `date`)\\n- **Comments** (`post_id`, `user_id`, `comment`, `date`)\\n\\nHere\u2019s what each table represents:\\n- **Users**: Stores user information.\\n- **Posts**: Represents content posted by users, linked to the `users` table.\\n- **Comments**: Stores user comments on posts, linked to both `posts` and `users`.\\n\\n---\\n\\n## **Creating Entity Classes**\\n\\n### **Step 1: The `User` Entity**\\n\\nThe `User` entity represents the `users` table. It has a one-to-many relationship with both `posts` and `comments`.\\n\\n```java\\nimport jakarta.persistence.*;\\nimport java.util.List;\\n\\n@Entity\\n@Table(name = \\"users\\")\\npublic class User {\\n    @Id\\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\\n    private Long id;\\n\\n    private String name;\\n    private String email;\\n\\n    @OneToMany(mappedBy = \\"user\\", cascade = CascadeType.ALL, orphanRemoval = true)\\n    private List<Post> posts;\\n\\n    @OneToMany(mappedBy = \\"user\\", cascade = CascadeType.ALL, orphanRemoval = true)\\n    private List<Comment> comments;\\n\\n    // Getters and Setters\\n}\\n```\\n\\n### **Step 2: The `Post` Entity**\\n\\nThe `Post` entity maps the `posts` table. It has a `ManyToOne` relationship with `User` and a `OneToMany` relationship with `Comment`.\\n\\n```java\\nimport jakarta.persistence.*;\\nimport java.time.LocalDate;\\nimport java.util.List;\\n\\n@Entity\\n@Table(name = \\"posts\\")\\npublic class Post {\\n    @Id\\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\\n    private Long id;\\n\\n    @ManyToOne\\n    @JoinColumn(name = \\"user_id\\", nullable = false)\\n    private User user;\\n\\n    private String title;\\n    private String content;\\n    private LocalDate date;\\n\\n    @OneToMany(mappedBy = \\"post\\", cascade = CascadeType.ALL, orphanRemoval = true)\\n    private List<Comment> comments;\\n\\n    // Getters and Setters\\n}\\n```\\n\\n### **Step 3: The `Comment` Entity with a Composite Key**\\n\\nUnlike the `User` and `Post` entities, the `Comment` entity uses a composite primary key (`post_id`, `user_id`). This eliminates the need for a separate `id` field. Here\u2019s how to implement it:\\n\\n#### **Composite Key Class (`CommentId`)**\\n\\n```java\\nimport jakarta.persistence.Embeddable;\\nimport java.io.Serializable;\\nimport java.util.Objects;\\n\\n@Embeddable\\npublic class CommentId implements Serializable {\\n\\n    private Long postId;\\n\\n    private Long userId;\\n\\n    // Default constructor\\n    public CommentId() {}\\n\\n    public CommentId(Long postId, Long userId) {\\n        this.postId = postId;\\n        this.userId = userId;\\n    }\\n\\n    // Getters and Setters\\n    \\n\\n    // Override equals() and hashCode()\\n    @Override\\n    public boolean equals(Object o) {\\n        if (this == o) return true;\\n        if (o == null || getClass() != o.getClass()) return false;\\n        CommentId that = (CommentId) o;\\n        return Objects.equals(postId, that.postId) &&\\n               Objects.equals(userId, that.userId);\\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return Objects.hash(postId, userId);\\n    }\\n}\\n```\\n\\n#### **The `Comment` Entity**\\n\\n```java\\nimport jakarta.persistence.*;\\nimport java.time.LocalDate;\\n\\n@Entity\\n@Table(name = \\"comments\\")\\npublic class Comment {\\n    @EmbeddedId\\n    private CommentId id;\\n\\n    @ManyToOne\\n    @MapsId(\\"postId\\")\\n    @JoinColumn(name = \\"post_id\\", nullable = false)\\n    private Post post;\\n\\n    @ManyToOne\\n    @MapsId(\\"userId\\")\\n    @JoinColumn(name = \\"user_id\\", nullable = false)\\n    private User user;\\n\\n    private String comment;\\n    private LocalDate date;\\n\\n    // Getters and Setters\\n}\\n```\\n\\n---\\n\\n## **Key Takeaways**\\n\\n1. **Relationships**:\\n   - Use `@ManyToOne` and `@OneToMany` for parent-child relationships.\\n   - For bidirectional relationships, annotate the owning side.\\n\\n2. **Composite Keys**:\\n   - Define a separate `@Embeddable` class to represent composite keys.\\n   - Use `@EmbeddedId` in the entity and `@MapsId` to map foreign keys.\\n\\n3. **Database Integrity**:\\n   - Ensure relationships are managed correctly with cascading and orphan removal policies.\\n\\n4. **Best Practices**:\\n   - Always override `equals()` and `hashCode()` in composite key classes.\\n   - Keep your entities simple and focused on mapping rather than business logic.\\n\\n---\\n\\n## **Conclusion**\\n\\nBy following these steps, you can create robust JPA entity classes tailored to your database schema. Whether you\'re using simple primary keys or composite keys, understanding JPA annotations and relationships is key to building scalable applications."},{"id":"what-is-spring-boot-starters","metadata":{"permalink":"/blog/what-is-spring-boot-starters","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2024-11-16-what-spring-boot-starters/index.md","source":"@site/blog/2024-11-16-what-spring-boot-starters/index.md","title":"What is Spring Boot Starter","description":"Introduction","date":"2024-11-16T00:00:00.000Z","tags":[{"inline":false,"label":"Spring","permalink":"/blog/tags/spring","description":"Spring Boot"},{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"Java"}],"readingTime":2.04,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"what-is-spring-boot-starters","title":"What is Spring Boot Starter","authors":["vijay"],"tags":["spring","java"]},"unlisted":false,"prevItem":{"title":"How to Create Entity Classes for Relational Tables","permalink":"/blog/how-to-create-entity-classes-for-relational-tables"},"nextItem":{"title":"What is Spring Framework","permalink":"/blog/what-is-spring-and-spring-boot"}},"content":"## Introduction\\n\\nSpring Boot starters are predefined templates or dependencies that simplify the process of setting up a Spring Boot application. They eliminate the need to manually define numerous dependencies, ensuring compatibility and reducing configuration effort.\\n\\nHere\u2019s a list of commonly used Spring Boot starters and their purposes:\\n\\n\x3c!-- truncate --\x3e\\n---\\n\\n## **Core Starters**\\n1. **spring-boot-starter**  \\n   - Base starter for any Spring Boot application.  \\n   - Includes essential dependencies like Spring Core, Logging, etc.\\n\\n2. **spring-boot-starter-test**  \\n   - Starter for testing Spring Boot applications.  \\n   - Includes JUnit, Mockito, Spring Test, and AssertJ.\\n\\n---\\n\\n## **Web Development**\\n3. **spring-boot-starter-web**  \\n   - For building RESTful web applications.  \\n   - Includes Spring MVC, Jackson (for JSON processing), and embedded Tomcat.\\n\\n4. **spring-boot-starter-webflux**  \\n   - For reactive web applications using Project Reactor and WebFlux.  \\n   - Includes Netty or Tomcat for reactive web servers.\\n\\n---\\n\\n## **Data Access**\\n5. **spring-boot-starter-data-jpa**  \\n   - For JPA-based repositories and Hibernate ORM.  \\n   - Includes Spring Data JPA and an H2 database.\\n\\n6. **spring-boot-starter-data-mongodb**  \\n   - For MongoDB support.  \\n   - Includes Spring Data MongoDB.\\n\\n7. **spring-boot-starter-data-redis**  \\n   - For Redis data access.  \\n   - Includes Spring Data Redis and Lettuce.\\n\\n8. **spring-boot-starter-jdbc**  \\n   - For traditional JDBC-based database access.  \\n   - Includes Spring JDBC and DataSource support.\\n\\n---\\n\\n## **Security**\\n9. **spring-boot-starter-security**  \\n   - Adds Spring Security to your application.  \\n   - Supports authentication, authorization, and secure login mechanisms.\\n\\n---\\n\\n## **Messaging**\\n10. **spring-boot-starter-amqp**  \\n    - For RabbitMQ messaging.  \\n    - Includes Spring AMQP.\\n\\n11. **spring-boot-starter-activemq**  \\n    - For ActiveMQ messaging.\\n\\n12. **spring-boot-starter-kafka**  \\n    - For Apache Kafka messaging.\\n\\n---\\n\\n## **Cloud & Configuration**\\n13. **spring-boot-starter-actuator**  \\n    - Adds production-ready features like monitoring and metrics endpoints.\\n\\n14. **spring-boot-starter-cloud-config**  \\n    - For using Spring Cloud Config to manage configuration across environments.\\n\\n---\\n\\n## **Template Engines**\\n15. **spring-boot-starter-thymeleaf**  \\n    - For server-side rendering with Thymeleaf templates.\\n\\n16. **spring-boot-starter-freemarker**  \\n    - For server-side rendering with FreeMarker templates.\\n\\n---\\n\\n## **Others**\\n17. **spring-boot-starter-batch**  \\n    - For batch processing using Spring Batch.\\n\\n18. **spring-boot-starter-cache**  \\n    - Adds caching capabilities to your application.\\n\\n19. **spring-boot-starter-mail**  \\n    - For sending emails.\\n\\n20. **spring-boot-starter-validation**  \\n    - For data validation using Hibernate Validator.\\n\\n21. **spring-boot-starter-aop**  \\n    - Adds support for aspect-oriented programming using Spring AOP.\\n\\n---\\n\\n## Why Use Spring Boot Starters?\\n- **Reduced Configuration:** Predefined dependencies ensure compatibility.\\n- **Improved Productivity:** Faster setup time for new projects.\\n- **Focused Development:** You can focus on business logic instead of boilerplate code.\\n\\nWould you like me to structure this further or add examples for specific starters?"},{"id":"what-is-spring-and-spring-boot","metadata":{"permalink":"/blog/what-is-spring-and-spring-boot","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2024-11-14-what-is-spring-and-spring-boot/index.md","source":"@site/blog/2024-11-14-what-is-spring-and-spring-boot/index.md","title":"What is Spring Framework","description":"Spring Framework","date":"2024-11-14T00:00:00.000Z","tags":[{"inline":false,"label":"Spring","permalink":"/blog/tags/spring","description":"Spring Boot"},{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"Java"}],"readingTime":2.22,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"what-is-spring-and-spring-boot","title":"What is Spring Framework","authors":["vijay"],"tags":["spring","java"]},"unlisted":false,"prevItem":{"title":"What is Spring Boot Starter","permalink":"/blog/what-is-spring-boot-starters"},"nextItem":{"title":"When to choose MySql vs PostgreSql relation databse","permalink":"/blog/When-to-choose-MySql-vs-PostgreSql-relation-databse"}},"content":"## Spring Framework\\n\\nThe **Spring Framework** is a comprehensive and widely-used framework in the Java ecosystem for building enterprise-level applications. Its core feature is **dependency injection (DI)**, which helps with the loose coupling of components, making applications easier to manage and test. Spring provides many modules for various tasks, like web development, data access, messaging, and more, making it highly modular and suitable for a variety of projects.\\n\\n\x3c!-- truncate --\x3e\\n\\n**Key Features of Spring Framework**:\\n1. **Dependency Injection (DI)** and **Inversion of Control (IoC)**: Simplifies object creation and dependency handling.\\n2. **Aspect-Oriented Programming (AOP)**: Adds cross-cutting concerns like logging and transaction management.\\n3. **Data Access**: Supports integration with JDBC, JPA, Hibernate, and other data access technologies.\\n4. **Web Development**: Spring MVC (Model-View-Controller) module helps in building web applications.\\n5. **Modularity**: Has different modules like Spring Core, Spring Data, Spring Web, Spring Security, etc.\\n\\n## Spring Boot\\n\\n**Spring Boot** is a project built on top of the Spring Framework that aims to simplify the process of creating stand-alone, production-ready Spring applications. It abstracts away much of the configuration and boilerplate code that is traditionally associated with setting up a Spring project. With Spring Boot, you can get a Spring application up and running with minimal setup.\\n\\n**Key Features of Spring Boot**:\\n1. **Auto-Configuration**: Automatically configures your application based on the dependencies you include in the project.\\n2. **Standalone Applications**: Allows you to create standalone applications that run with `java -jar` commands.\\n3. **Embedded Servers**: Comes with embedded servers (like Tomcat, Jetty), so you don\u2019t need to deploy the application to an external server.\\n4. **Spring Boot Starters**: Simplifies dependency management by providing pre-configured sets of libraries (Starters) for different use cases (e.g., `spring-boot-starter-web` for web applications).\\n5. **Production-Ready Features**: Provides metrics, health checks, and externalized configuration to help in production management.\\n\\n## Relationship Between Spring Framework and Spring Boot\\n\\n- **Spring Framework** is the foundation of Spring-based projects and includes all the core functionalities, like DI, AOP, and MVC. Spring Boot, however, is built on top of the Spring Framework to simplify the process of developing Spring applications.\\n- **Spring Boot** is not a replacement but an enhancement for the Spring Framework, offering tools and defaults that help developers to rapidly create applications without writing too much configuration.\\n- **Spring Boot** leverages the components of the Spring Framework but adds its layer of abstraction, allowing for quick setup and ready-to-use defaults, especially useful for microservices and RESTful APIs.\\n\\nIn summary, **Spring Framework** provides the core infrastructure, while **Spring Boot** makes it easier to create applications with Spring by reducing configuration and simplifying the setup process."},{"id":"When-to-choose-MySql-vs-PostgreSql-relation-databse","metadata":{"permalink":"/blog/When-to-choose-MySql-vs-PostgreSql-relation-databse","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2024-09-26-mysql-vs-postgresql/index.md","source":"@site/blog/2024-09-26-mysql-vs-postgresql/index.md","title":"When to choose MySql vs PostgreSql relation databse","description":"Choosing between MySQL and PostgreSQL depends on your project requirements, data complexity, and specific use cases. Here\u2019s a breakdown of when to choose each:","date":"2024-09-26T00:00:00.000Z","tags":[{"inline":false,"label":"Database","permalink":"/blog/tags/database","description":"Database"}],"readingTime":1.62,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"When-to-choose-MySql-vs-PostgreSql-relation-databse","title":"When to choose MySql vs PostgreSql relation databse","authors":["vijay"],"tags":["database"]},"unlisted":false,"prevItem":{"title":"What is Spring Framework","permalink":"/blog/what-is-spring-and-spring-boot"},"nextItem":{"title":"Instrumenting Spring Boot Applications with OpenTelemetry (Without Java Agent)","permalink":"/blog/Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent"}},"content":"Choosing between MySQL and PostgreSQL depends on your project requirements, data complexity, and specific use cases. Here\u2019s a breakdown of when to choose each:\\n\\n## **When to Choose MySQL**\\n\\n1. **Simplicity and Ease of Use**: Ideal for beginners or small applications where quick setup and ease of management are priorities.\\n\x3c!-- truncate --\x3e\\n\\n2. **Read-Heavy Workloads**: Best suited for applications with high read-to-write ratios, such as content management systems or websites with static data.\\n\\n3. **Speed**: MySQL can outperform PostgreSQL in certain read-heavy scenarios due to its optimization for fast reads.\\n\\n4. **Web Applications**: Commonly used in web applications, especially with PHP and frameworks like WordPress.\\n\\n5. **Replication Needs**: Offers simpler replication features, making it a good choice for applications requiring master-slave replication.\\n\\n## **When to Choose PostgreSQL**\\n\\n1. **Complex Queries**: Preferred for applications requiring complex queries, advanced data types, and powerful analytical capabilities.\\n\\n2. **Data Integrity and Compliance**: Stronger support for ACID compliance, making it suitable for applications that demand data integrity, such as financial systems.\\n\\n3. **Advanced Features**: Supports advanced features like full-text search, JSONB data type, and GIS capabilities (PostGIS).\\n\\n4. **Concurrency**: Better at handling concurrent transactions due to its MVCC (Multiversion Concurrency Control) architecture.\\n\\n5. **Extensibility**: Allows for custom data types, functions, and operators, making it highly customizable for specialized applications.\\n\\n6. **Geospatial Data**: Excellent choice if you need to handle geospatial data with complex queries.\\n\\n## **Considerations for Both**\\n\\n- **Community and Support**: Both databases have strong communities and plenty of resources available.\\n- **Hosting**: Check if your hosting provider supports the database of your choice and offers optimized configurations.\\n- **Migration Plans**: If you plan to scale your application, consider how easy it is to migrate from one database to another.\\n\\n## **Conclusion**\\n\\n- Choose **MySQL** for simpler, read-heavy applications with less complexity.\\n- Opt for **PostgreSQL** when you need advanced features, complex queries, and robust data integrity.\\n\\nEvaluate your specific use case and performance requirements to make the best choice!"},{"id":"Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent","metadata":{"permalink":"/blog/Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2024-08-14-Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent/index.md","source":"@site/blog/2024-08-14-Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent/index.md","title":"Instrumenting Spring Boot Applications with OpenTelemetry (Without Java Agent)","description":"Introduction","date":"2024-08-14T00:00:00.000Z","tags":[{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"Java"}],"readingTime":2.26,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent","title":"Instrumenting Spring Boot Applications with OpenTelemetry (Without Java Agent)","authors":["vijay"],"tags":["java"]},"unlisted":false,"prevItem":{"title":"When to choose MySql vs PostgreSql relation databse","permalink":"/blog/When-to-choose-MySql-vs-PostgreSql-relation-databse"},"nextItem":{"title":"What Is Stream In java","permalink":"/blog/what-is-stream-in-java"}},"content":"## **Introduction**\\n\\nIn modern distributed systems, observability is crucial for monitoring application performance and troubleshooting issues. OpenTelemetry (OTel) is a powerful tool for collecting telemetry data such as traces, metrics, and logs. In this guide, we\'ll walk through how to instrument a Spring Boot application with OpenTelemetry without using the Java agent, and how to export the telemetry data to Jaeger using Docker.\\n\\n\x3c!-- truncate --\x3e\\n\\n## **Step 1: Setting Up OpenTelemetry in Spring Boot**\\n\\nFirst, you\'ll need to add the necessary OpenTelemetry dependencies to your Spring Boot project. Here\'s how to do it with Gradle:\\n\\n```groovy\\ndependencies {\\n    implementation(platform(\\"io.opentelemetry.instrumentation:opentelemetry-instrumentation-bom:2.6.0\\"))\\n    implementation(\\"io.opentelemetry.instrumentation:opentelemetry-spring-boot-starter\\")\\n}\\n```\\n\\nThese dependencies bring in the OpenTelemetry SDK and the Spring Boot starter, which helps in auto-configuring the instrumentation of your application.\\n\\n## **Step 2: Configuring OpenTelemetry in Spring Boot**\\n\\nNext, configure OpenTelemetry in your `application.yml` (or `application.properties`) to define how traces are exported and propagated:\\n\\n```yaml\\notel:\\n  traces:\\n    exporter: otlp\\n  exporter:\\n    otlp:\\n      endpoint: http://localhost:4317\\n      protocol: grpc\\n  propagators:\\n    - tracecontext\\n  resource:\\n    attributes:\\n      deployment.environment: dev\\n      service:\\n        name: webflux\\n        namespace: spring\\n```\\n\\nHere\u2019s what each part does:\\n\\n- **traces.exporter.otlp**: Specifies the OTLP (OpenTelemetry Protocol) as the exporter.\\n- **exporter.otlp.endpoint**: The endpoint where the traces will be sent.\\n- **propagators**: Configures the trace context propagation.\\n- **resource.attributes**: Adds metadata like environment and service name to the traces.\\n\\n## **Step 3: Running Jaeger with Docker Compose**\\n\\nTo visualize the traces, you\'ll need a tool like Jaeger. Here\u2019s a `docker-compose.yml` setup that runs Jaeger with Elasticsearch as the storage backend:\\n\\n```yaml\\nversion: \\"3.7\\"\\n\\nservices:\\n  jaeger-collector:\\n    image: jaegertracing/jaeger-collector:1.40\\n    environment:\\n      - COLLECTOR_OTLP_ENABLED=true # Enable OTLP endpoint\\n      - SPAN_STORAGE_TYPE=elasticsearch\\n      - ES_SERVER_URLS=http://elasticsearch:9200\\n    ports:\\n      - \\"14250:14250\\" # OTLP gRPC\\n      - \\"14268:14268\\" # Jaeger HTTP Thrift\\n      - \\"4317:4317\\" # OTLP gRPC for traces\\n      - \\"4318:4318\\" # OTLP HTTP for traces\\n    depends_on:\\n      - elasticsearch\\n    networks:\\n      - jaeger-network\\n\\n  jaeger-query:\\n    image: jaegertracing/jaeger-query:1.40\\n    environment:\\n      - SPAN_STORAGE_TYPE=elasticsearch\\n      - ES_SERVER_URLS=http://elasticsearch:9200\\n    ports:\\n      - \\"16686:16686\\" # Jaeger UI\\n    depends_on:\\n      - jaeger-collector\\n    networks:\\n      - jaeger-network\\n\\n  elasticsearch:\\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.10.2\\n    environment:\\n      - discovery.type=single-node\\n    ports:\\n      - \\"9200:9200\\"\\n    networks:\\n      - jaeger-network\\n\\nnetworks:\\n  jaeger-network:\\n    driver: bridge\\n```\\n\\nThis setup creates three services:\\n\\n- **Jaeger Collector**: Collects traces from your application.\\n- **Jaeger Query**: Provides a UI to view and query traces.\\n- **Elasticsearch**: Stores the trace data.\\n\\n## **Step 4: Testing the Setup**\\n\\nOnce everything is configured, start your application and the Docker Compose setup. Generate some traffic in your application to produce traces. You should see the traces appear in the Jaeger UI at `http://localhost:16686`.\\n\\n## **Conclusion**\\n\\nBy following these steps, you\'ve successfully instrumented your Spring Boot application with OpenTelemetry, configured it to export traces to Jaeger, and visualized the traces without using the OpenTelemetry Java agent. This approach offers flexibility and control over how your application is instrumented."},{"id":"what-is-stream-in-java","metadata":{"permalink":"/blog/what-is-stream-in-java","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2024-06-15-what-is-stream-in-java/index.md","source":"@site/blog/2024-06-15-what-is-stream-in-java/index.md","title":"What Is Stream In java","description":"Introduction","date":"2024-06-15T00:00:00.000Z","tags":[{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"Java"}],"readingTime":2.57,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"what-is-stream-in-java","title":"What Is Stream In java","authors":["vijay"],"tags":["java"]},"unlisted":false,"prevItem":{"title":"Instrumenting Spring Boot Applications with OpenTelemetry (Without Java Agent)","permalink":"/blog/Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent"},"nextItem":{"title":"Build Docker Image Using Jib","permalink":"/blog/build-docker-image-using-jib"}},"content":"## Introduction\\n\\nA sequence of elements in Java that supports several methods that can be pipelined to achieve a desired outcome is called a stream. Originally included in Java 8 as a component of the java.util.stream package, streams are a part of the Java Collections Framework. They are made to manipulate data declaratively, much like SQL does with information kept in tables.\\n\\n\x3c!--truncate--\x3e\\n\\n## Key Characteristics of Streams\\n\\n1. **Sequence of Elements**: A stream provides a sequence of elements, where each element is processed one at a time.\\n2. **Functional in Nature**: Operations on a stream are performed using a functional programming approach, allowing for concise and readable code.\\n3. **Lazy Evaluation**: Stream operations are lazy; they are not executed until a terminal operation is invoked. This allows for optimization and efficient processing.\\n4. **Parallel Processing**: Streams can be easily parallelized, making it simple to perform operations on multiple elements concurrently.\\n\\n## Types of Stream Operations\\n\\nThere are two main types of stream operations: intermediate and terminal operations.\\n\\n**Intermediate Operations**:\\n- These operations return a new stream and are lazy, meaning they do not trigger any processing until a terminal operation is invoked.\\n- Examples include `filter()`, `map()`, `flatMap()`, `distinct()`, `sorted()`, and `limit()`.\\n\\n**Terminal Operations**:\\n- These operations trigger the actual processing of the stream and produce a result or a side-effect.\\n- Examples include `forEach()`, `collect()`, `reduce()`, `count()`, `findFirst()`, and `allMatch()`.\\n\\n## Creating Streams\\n\\nStreams can be created from various data sources such as collections, arrays, and I/O channels. Here are some examples:\\n\\n**From Collections**:\\n```java\\nList<String> list = Arrays.asList(\\"a\\", \\"b\\", \\"c\\");\\nStream<String> stream = list.stream();\\n```\\n\\n**From Arrays**:\\n```java\\nString[] array = {\\"a\\", \\"b\\", \\"c\\"};\\nStream<String> stream = Arrays.stream(array);\\n```\\n\\n**From Lines of a File**:\\n```java\\nStream<String> lines = Files.lines(Paths.get(\\"file.txt\\"));\\n```\\n\\n**From Values**:\\n```java\\nStream<String> stream = Stream.of(\\"a\\", \\"b\\", \\"c\\");\\n```\\n\\n## Common Stream Operations\\n\\nHere are some common operations performed on streams:\\n\\n**Filtering**:\\n```java\\nList<String> filteredList = list.stream()\\n                                .filter(s -> s.startsWith(\\"a\\"))\\n                                .collect(Collectors.toList());\\n```\\n\\n**Mapping**:\\n```java\\nList<Integer> lengths = list.stream()\\n                            .map(String::length)\\n                            .collect(Collectors.toList());\\n```\\n\\n**Reducing**:\\n```java\\nOptional<String> concatenated = list.stream()\\n                                    .reduce((s1, s2) -> s1 + s2);\\n```\\n\\n**Collecting**:\\n```java\\nList<String> collected = list.stream()\\n                             .sorted()\\n                             .collect(Collectors.toList());\\n```\\n\\n**Parallel Streams**:\\n```java\\nList<String> parallelList = list.parallelStream()\\n                                .filter(s -> s.startsWith(\\"a\\"))\\n                                .collect(Collectors.toList());\\n```\\n\\n## Example Usage\\n\\nHere\'s a complete example that demonstrates the use of various stream operations:\\n\\n```java\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.stream.Collectors;\\n\\npublic class StreamExample {\\n    public static void main(String[] args) {\\n        List<String> names = Arrays.asList(\\"Ram\\", \\"Krishna\\", \\"Chanakya\\", \\"Patel\\", \\"Lakshman\\");\\n\\n        // Convert all names to uppercase and filter names that start with \'A\'\\n        List<String> result = names.stream()\\n                                   .map(String::toUpperCase)\\n                                   .filter(name -> name.startsWith(\\"R\\"))\\n                                   .collect(Collectors.toList());\\n\\n        // Print the result\\n        result.forEach(System.out::println);\\n    }\\n}\\n```\\n\\nIn this example, the `names` list is converted to a stream, each name is mapped to its uppercase form, filtered to retain names starting with `R`, and then collected into a new list, which is printed to the console.\\n\\n## Conclusion\\n\\nStreams in Java provide a powerful and flexible way to perform complex data processing tasks in a declarative and efficient manner. They enable functional-style operations on collections of elements, making it easier to write concise and readable code."},{"id":"build-docker-image-using-jib","metadata":{"permalink":"/blog/build-docker-image-using-jib","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2024-06-08-build-docker-image-using-jib/index.md","source":"@site/blog/2024-06-08-build-docker-image-using-jib/index.md","title":"Build Docker Image Using Jib","description":"Docker Build","date":"2024-06-08T00:00:00.000Z","tags":[{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"Java"},{"inline":false,"label":"Spring","permalink":"/blog/tags/spring","description":"Spring Boot"}],"readingTime":1.75,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"build-docker-image-using-jib","title":"Build Docker Image Using Jib","authors":["vijay"],"tags":["java","spring"]},"unlisted":false,"prevItem":{"title":"What Is Stream In java","permalink":"/blog/what-is-stream-in-java"}},"content":"![Docker Build](./docker-build.png)\\n\\n## Overview\\n\\nThis blog post introduces Jib, a powerful tool for building optimized Docker images for Java applications. Jib stands out by eliminating the need for a Docker daemon and expertise in Docker best practices, making it a convenient option for developers. Integrated as a plugin in Gradle or Maven projects, Jib simplifies the process of containerizing Java applications.\\n\\n\x3c!--truncate--\x3e\\n\\n## What is Jib?\\n\\nJib builds optimized Docker images for your Java applications without a Docker daemon or deep mastery of Docker best practices.\\nYou can use it as a plugin in your Gradle or Maven project.\\n\\n## Let\'s configure gradle to use Jib\\n\\nJib is used as a plugin, so we need to update the `build.gradle` file. We simply need to add the Jib plugin and define the Jib configuration block.\\n\\n```gradle title=\\"build.gradle\\"\\nplugins {\\n    . . .\\n    id \'com.google.cloud.tools.jib\' version \'3.1.1\'\\n}\\n\\n. . .\\n\\njib {\\n    from {\\n        image = \\"amazoncorretto:11\\"\\n    }\\n    to {\\n        image = \\"docker.io/vijaypatidar31/webflux\\"\\n        tags = [\\"latest\\", version]\\n    }\\n    container {\\n        mainClass = \\"com.vkpapps.demo.CoolSpringWebfluxApplication\\"\\n        jvmFlags = []\\n        ports = [\\"443\\"]\\n    }\\n}\\n```\\n\\n## Build And Publish Image To Docker Registry\\n\\nAfter configuring the jib block, you can run a gradle task to build and publish an image to the Docker registry (gradle jib).\\n\\n## Benefits\\n\\n- Using Jib over a traditional Dockerfile for building and packaging Java applications offers several benefits:\\n- Simplified Configuration: Integrates with Gradle/Maven, eliminating the need for a separate Dockerfile.\\n- Faster Builds: Uses advanced caching mechanisms, reducing the need to rebuild unchanged layers.\\n- Reproducible Builds: Ensures builds are reproducible by isolating the build environment from the runtime environment.\\n- No Docker Daemon Required: Builds Docker images without requiring a Docker daemon, suitable for CI/CD pipelines or restricted environments.\\n- Automatic Base Image Updates: This can automatically pull the latest base image, ensuring the use of up-to-date images with the latest security patches.\\n- Layered Image Construction: Automatically separates the application into layers, optimizing the build and pushing process.\\n- Integration with Container Registries: Seamlessly integrates with popular container registries, making it easy to push images directly from your build tool.\\n- Advanced Configuration Options: Provides options for customizing the image build, such as specifying entry points, environment variables, JVM flags, and exposed ports."}]}}')}}]);