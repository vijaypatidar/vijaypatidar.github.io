"use strict";(self.webpackChunkmy_portfolio=self.webpackChunkmy_portfolio||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"When-to-choose-MySql-vs-PostgreSql-relation-databse","metadata":{"permalink":"/blog/When-to-choose-MySql-vs-PostgreSql-relation-databse","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2024-09-26-mysql-vs-postgresql/index.md","source":"@site/blog/2024-09-26-mysql-vs-postgresql/index.md","title":"When to choose MySql vs PostgreSql relation databse","description":"Choosing between MySQL and PostgreSQL depends on your project requirements, data complexity, and specific use cases. Here\u2019s a breakdown of when to choose each:","date":"2024-09-26T00:00:00.000Z","tags":[{"inline":false,"label":"Database","permalink":"/blog/tags/database","description":"Database"}],"readingTime":1.635,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"When-to-choose-MySql-vs-PostgreSql-relation-databse","title":"When to choose MySql vs PostgreSql relation databse","authors":["vijay"],"tags":["database"]},"unlisted":false,"nextItem":{"title":"Instrumenting Spring Boot Applications with OpenTelemetry (Without Java Agent)","permalink":"/blog/Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent"}},"content":"Choosing between MySQL and PostgreSQL depends on your project requirements, data complexity, and specific use cases. Here\u2019s a breakdown of when to choose each:\\n\\n### **When to Choose MySQL**\\n\\n1. **Simplicity and Ease of Use**: Ideal for beginners or small applications where quick setup and ease of management are priorities.\\n\x3c!-- truncate --\x3e\\n\\n2. **Read-Heavy Workloads**: Best suited for applications with high read-to-write ratios, such as content management systems or websites with static data.\\n\\n3. **Speed**: MySQL can outperform PostgreSQL in certain read-heavy scenarios due to its optimization for fast reads.\\n\\n4. **Web Applications**: Commonly used in web applications, especially with PHP and frameworks like WordPress.\\n\\n5. **Replication Needs**: Offers simpler replication features, making it a good choice for applications requiring master-slave replication.\\n\\n### **When to Choose PostgreSQL**\\n\\n1. **Complex Queries**: Preferred for applications requiring complex queries, advanced data types, and powerful analytical capabilities.\\n\\n2. **Data Integrity and Compliance**: Stronger support for ACID compliance, making it suitable for applications that demand data integrity, such as financial systems.\\n\\n3. **Advanced Features**: Supports advanced features like full-text search, JSONB data type, and GIS capabilities (PostGIS).\\n\\n4. **Concurrency**: Better at handling concurrent transactions due to its MVCC (Multiversion Concurrency Control) architecture.\\n\\n5. **Extensibility**: Allows for custom data types, functions, and operators, making it highly customizable for specialized applications.\\n\\n6. **Geospatial Data**: Excellent choice if you need to handle geospatial data with complex queries.\\n\\n### **Considerations for Both**\\n\\n- **Community and Support**: Both databases have strong communities and plenty of resources available.\\n- **Hosting**: Check if your hosting provider supports the database of your choice and offers optimized configurations.\\n- **Migration Plans**: If you plan to scale your application, consider how easy it is to migrate from one database to another.\\n\\n### **Conclusion**\\n\\n- Choose **MySQL** for simpler, read-heavy applications with less complexity.\\n- Opt for **PostgreSQL** when you need advanced features, complex queries, and robust data integrity.\\n\\nEvaluate your specific use case and performance requirements to make the best choice!"},{"id":"Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent","metadata":{"permalink":"/blog/Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2024-08-14-Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent/index.md","source":"@site/blog/2024-08-14-Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent/index.md","title":"Instrumenting Spring Boot Applications with OpenTelemetry (Without Java Agent)","description":"Introduction","date":"2024-08-14T00:00:00.000Z","tags":[{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"Java"}],"readingTime":2.235,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent","title":"Instrumenting Spring Boot Applications with OpenTelemetry (Without Java Agent)","authors":["vijay"],"tags":["java"]},"unlisted":false,"prevItem":{"title":"When to choose MySql vs PostgreSql relation databse","permalink":"/blog/When-to-choose-MySql-vs-PostgreSql-relation-databse"},"nextItem":{"title":"What Is Stream In java","permalink":"/blog/what-is-stream-in-java"}},"content":"### **Introduction**\\n\\nIn modern distributed systems, observability is crucial for monitoring application performance and troubleshooting issues. OpenTelemetry (OTel) is a powerful tool for collecting telemetry data such as traces, metrics, and logs. In this guide, we\'ll walk through how to instrument a Spring Boot application with OpenTelemetry without using the Java agent, and how to export the telemetry data to Jaeger using Docker.\\n\\n\x3c!-- truncate --\x3e\\n\\n### **Step 1: Setting Up OpenTelemetry in Spring Boot**\\n\\nFirst, you\'ll need to add the necessary OpenTelemetry dependencies to your Spring Boot project. Here\'s how to do it with Gradle:\\n\\n```groovy\\ndependencies {\\n    implementation(platform(\\"io.opentelemetry.instrumentation:opentelemetry-instrumentation-bom:2.6.0\\"))\\n    implementation(\\"io.opentelemetry.instrumentation:opentelemetry-spring-boot-starter\\")\\n}\\n```\\n\\nThese dependencies bring in the OpenTelemetry SDK and the Spring Boot starter, which helps in auto-configuring the instrumentation of your application.\\n\\n### **Step 2: Configuring OpenTelemetry in Spring Boot**\\n\\nNext, configure OpenTelemetry in your `application.yml` (or `application.properties`) to define how traces are exported and propagated:\\n\\n```yaml\\notel:\\n  traces:\\n    exporter: otlp\\n  exporter:\\n    otlp:\\n      endpoint: http://localhost:4317\\n      protocol: grpc\\n  propagators:\\n    - tracecontext\\n  resource:\\n    attributes:\\n      deployment.environment: dev\\n      service:\\n        name: webflux\\n        namespace: spring\\n```\\n\\nHere\u2019s what each part does:\\n\\n- **traces.exporter.otlp**: Specifies the OTLP (OpenTelemetry Protocol) as the exporter.\\n- **exporter.otlp.endpoint**: The endpoint where the traces will be sent.\\n- **propagators**: Configures the trace context propagation.\\n- **resource.attributes**: Adds metadata like environment and service name to the traces.\\n\\n### **Step 3: Running Jaeger with Docker Compose**\\n\\nTo visualize the traces, you\'ll need a tool like Jaeger. Here\u2019s a `docker-compose.yml` setup that runs Jaeger with Elasticsearch as the storage backend:\\n\\n```yaml\\nversion: \\"3.7\\"\\n\\nservices:\\n  jaeger-collector:\\n    image: jaegertracing/jaeger-collector:1.40\\n    environment:\\n      - COLLECTOR_OTLP_ENABLED=true # Enable OTLP endpoint\\n      - SPAN_STORAGE_TYPE=elasticsearch\\n      - ES_SERVER_URLS=http://elasticsearch:9200\\n    ports:\\n      - \\"14250:14250\\" # OTLP gRPC\\n      - \\"14268:14268\\" # Jaeger HTTP Thrift\\n      - \\"4317:4317\\" # OTLP gRPC for traces\\n      - \\"4318:4318\\" # OTLP HTTP for traces\\n    depends_on:\\n      - elasticsearch\\n    networks:\\n      - jaeger-network\\n\\n  jaeger-query:\\n    image: jaegertracing/jaeger-query:1.40\\n    environment:\\n      - SPAN_STORAGE_TYPE=elasticsearch\\n      - ES_SERVER_URLS=http://elasticsearch:9200\\n    ports:\\n      - \\"16686:16686\\" # Jaeger UI\\n    depends_on:\\n      - jaeger-collector\\n    networks:\\n      - jaeger-network\\n\\n  elasticsearch:\\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.10.2\\n    environment:\\n      - discovery.type=single-node\\n    ports:\\n      - \\"9200:9200\\"\\n    networks:\\n      - jaeger-network\\n\\nnetworks:\\n  jaeger-network:\\n    driver: bridge\\n```\\n\\nThis setup creates three services:\\n\\n- **Jaeger Collector**: Collects traces from your application.\\n- **Jaeger Query**: Provides a UI to view and query traces.\\n- **Elasticsearch**: Stores the trace data.\\n\\n### **Step 4: Testing the Setup**\\n\\nOnce everything is configured, start your application and the Docker Compose setup. Generate some traffic in your application to produce traces. You should see the traces appear in the Jaeger UI at `http://localhost:16686`.\\n\\n### **Conclusion**\\n\\nBy following these steps, you\'ve successfully instrumented your Spring Boot application with OpenTelemetry, configured it to export traces to Jaeger, and visualized the traces without using the OpenTelemetry Java agent. This approach offers flexibility and control over how your application is instrumented."},{"id":"what-is-stream-in-java","metadata":{"permalink":"/blog/what-is-stream-in-java","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2024-06-15-what-is-stream-in-java/index.md","source":"@site/blog/2024-06-15-what-is-stream-in-java/index.md","title":"What Is Stream In java","description":"Introduction","date":"2024-06-15T00:00:00.000Z","tags":[{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"Java"}],"readingTime":2.59,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"what-is-stream-in-java","title":"What Is Stream In java","authors":["vijay"],"tags":["java"]},"unlisted":false,"prevItem":{"title":"Instrumenting Spring Boot Applications with OpenTelemetry (Without Java Agent)","permalink":"/blog/Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent"},"nextItem":{"title":"Build Docker Image Using Jib","permalink":"/blog/build-docker-image-using-jib"}},"content":"## Introduction\\n\\nA sequence of elements in Java that supports several methods that can be pipelined to achieve a desired outcome is called a stream. Originally included in Java 8 as a component of the java.util.stream package, streams are a part of the Java Collections Framework. They are made to manipulate data declaratively, much like SQL does with information kept in tables.\\n\\n\x3c!--truncate--\x3e\\n\\n## Key Characteristics of Streams\\n\\n1. **Sequence of Elements**: A stream provides a sequence of elements, where each element is processed one at a time.\\n2. **Functional in Nature**: Operations on a stream are performed using a functional programming approach, allowing for concise and readable code.\\n3. **Lazy Evaluation**: Stream operations are lazy; they are not executed until a terminal operation is invoked. This allows for optimization and efficient processing.\\n4. **Parallel Processing**: Streams can be easily parallelized, making it simple to perform operations on multiple elements concurrently.\\n\\n## Types of Stream Operations\\n\\nThere are two main types of stream operations: intermediate and terminal operations.\\n\\n**Intermediate Operations**:\\n- These operations return a new stream and are lazy, meaning they do not trigger any processing until a terminal operation is invoked.\\n- Examples include `filter()`, `map()`, `flatMap()`, `distinct()`, `sorted()`, and `limit()`.\\n\\n**Terminal Operations**:\\n- These operations trigger the actual processing of the stream and produce a result or a side-effect.\\n- Examples include `forEach()`, `collect()`, `reduce()`, `count()`, `findFirst()`, and `allMatch()`.\\n\\n## Creating Streams\\n\\nStreams can be created from various data sources such as collections, arrays, and I/O channels. Here are some examples:\\n\\n**From Collections**:\\n```java\\nList<String> list = Arrays.asList(\\"a\\", \\"b\\", \\"c\\");\\nStream<String> stream = list.stream();\\n```\\n\\n**From Arrays**:\\n```java\\nString[] array = {\\"a\\", \\"b\\", \\"c\\"};\\nStream<String> stream = Arrays.stream(array);\\n```\\n\\n**From Lines of a File**:\\n```java\\nStream<String> lines = Files.lines(Paths.get(\\"file.txt\\"));\\n```\\n\\n**From Values**:\\n```java\\nStream<String> stream = Stream.of(\\"a\\", \\"b\\", \\"c\\");\\n```\\n\\n## Common Stream Operations\\n\\nHere are some common operations performed on streams:\\n\\n**Filtering**:\\n```java\\nList<String> filteredList = list.stream()\\n                                .filter(s -> s.startsWith(\\"a\\"))\\n                                .collect(Collectors.toList());\\n```\\n\\n**Mapping**:\\n```java\\nList<Integer> lengths = list.stream()\\n                            .map(String::length)\\n                            .collect(Collectors.toList());\\n```\\n\\n**Reducing**:\\n```java\\nOptional<String> concatenated = list.stream()\\n                                    .reduce((s1, s2) -> s1 + s2);\\n```\\n\\n**Collecting**:\\n```java\\nList<String> collected = list.stream()\\n                             .sorted()\\n                             .collect(Collectors.toList());\\n```\\n\\n**Parallel Streams**:\\n```java\\nList<String> parallelList = list.parallelStream()\\n                                .filter(s -> s.startsWith(\\"a\\"))\\n                                .collect(Collectors.toList());\\n```\\n\\n## Example Usage\\n\\nHere\'s a complete example that demonstrates the use of various stream operations:\\n\\n```java\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.stream.Collectors;\\n\\npublic class StreamExample {\\n    public static void main(String[] args) {\\n        List<String> names = Arrays.asList(\\"Ram\\", \\"Krishna\\", \\"Chanakya\\", \\"Patel\\", \\"Lakshman\\");\\n\\n        // Convert all names to uppercase and filter names that start with \'A\'\\n        List<String> result = names.stream()\\n                                   .map(String::toUpperCase)\\n                                   .filter(name -> name.startsWith(\\"R\\"))\\n                                   .collect(Collectors.toList());\\n\\n        // Print the result\\n        result.forEach(System.out::println);\\n    }\\n}\\n```\\n\\nIn this example, the `names` list is converted to a stream, each name is mapped to its uppercase form, filtered to retain names starting with `R`, and then collected into a new list, which is printed to the console.\\n\\n## Conclusion\\n\\nStreams in Java provide a powerful and flexible way to perform complex data processing tasks in a declarative and efficient manner. They enable functional-style operations on collections of elements, making it easier to write concise and readable code."},{"id":"build-docker-image-using-jib","metadata":{"permalink":"/blog/build-docker-image-using-jib","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2024-06-08-build-docker-image-using-jib/index.md","source":"@site/blog/2024-06-08-build-docker-image-using-jib/index.md","title":"Build Docker Image Using Jib","description":"Docker Build","date":"2024-06-08T00:00:00.000Z","tags":[{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"Java"},{"inline":false,"label":"Spring","permalink":"/blog/tags/spring","description":"Spring Boot"}],"readingTime":1.89,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"build-docker-image-using-jib","title":"Build Docker Image Using Jib","authors":["vijay"],"tags":["java","spring"]},"unlisted":false,"prevItem":{"title":"What Is Stream In java","permalink":"/blog/what-is-stream-in-java"}},"content":"![Docker Build](./docker-build.png)\\n\\n## Overview\\n\\nThis blog post introduces Jib, a powerful tool for building optimized Docker images for Java applications. Jib stands out by eliminating the need for a Docker daemon and expertise in Docker best practices, making it a convenient option for developers. Integrated as a plugin in Gradle or Maven projects, Jib simplifies the process of containerizing Java applications.\\n\\n\x3c!--truncate--\x3e\\n\\n## What is Jib?\\n\\nJib builds optimized Docker images for your Java applications without a Docker daemon or deep mastery of Docker best practices.\\nYou can use it as a plugin in your Gradle or Maven project.\\n\\n## Let\'s configure gradle to use Jib\\n\\nJib is used as a plugin, so we need to update the `build.gradle` file. We simply need to add the Jib plugin and define the Jib configuration block.\\n\\n```gradle title=\\"build.gradle\\"\\nplugins {\\n    . . .\\n    id \'com.google.cloud.tools.jib\' version \'3.1.1\'\\n}\\n\\n. . .\\n\\njib {\\n    from {\\n        image = \\"amazoncorretto:11\\"\\n    }\\n    to {\\n        image = \\"docker.io/vijaypatidar31/webflux\\"\\n        tags = [\\"latest\\", version]\\n    }\\n    container {\\n        mainClass = \\"com.vkpapps.demo.CoolSpringWebfluxApplication\\"\\n        jvmFlags = []\\n        ports = [\\"443\\"]\\n    }\\n}\\n```\\n\\n## Build And Publish Image To Docker Registry\\n\\nAfter configuring the jib block, you can run a gradle task to build and publish an image to the Docker registry (gradle jib).\\n\\n## Benefits\\n\\n- Using Jib over a traditional Dockerfile for building and packaging Java applications offers several benefits:\\n- Simplified Configuration: Integrates with Gradle/Maven, eliminating the need for a separate Dockerfile.\\n- Faster Builds: Uses advanced caching mechanisms, reducing the need to rebuild unchanged layers.\\n- Reproducible Builds: Ensures builds are reproducible by isolating the build environment from the runtime environment.\\n- No Docker Daemon Required: Builds Docker images without requiring a Docker daemon, suitable for CI/CD pipelines or restricted environments.\\n- Automatic Base Image Updates: This can automatically pull the latest base image, ensuring the use of up-to-date images with the latest security patches.\\n- Layered Image Construction: Automatically separates the application into layers, optimizing the build and pushing process.\\n- Integration with Container Registries: Seamlessly integrates with popular container registries, making it easy to push images directly from your build tool.\\n- Advanced Configuration Options: Provides options for customizing the image build, such as specifying entry points, environment variables, JVM flags, and exposed ports."}]}}')}}]);