"use strict";(self.webpackChunkmy_portfolio=self.webpackChunkmy_portfolio||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"how-to-create-entity-classes-for-relational-tables","metadata":{"permalink":"/blog/how-to-create-entity-classes-for-relational-tables","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2024-12-07-how-to-create-entity-classes-for-relational-tables/index.md","source":"@site/blog/2024-12-07-how-to-create-entity-classes-for-relational-tables/index.md","title":"How to Create Entity Classes for Relational Tables","description":"How to Create Entity Classes for Relational Tables","date":"2024-12-07T00:00:00.000Z","tags":[{"inline":false,"label":"JPA","permalink":"/blog/tags/jpa","description":"Java Persistence API"},{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"Java"}],"readingTime":3.06,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"how-to-create-entity-classes-for-relational-tables","title":"How to Create Entity Classes for Relational Tables","authors":["vijay"],"tags":["jpa","java"]},"unlisted":false,"nextItem":{"title":"What is Spring Boot Starter","permalink":"/blog/what-is-spring-boot-starters"}},"content":"## **How to Create Entity Classes for Relational Tables**\\n\\nWhen working with Java Persistence API (JPA), defining entity classes is a critical step to map relational database tables to Java objects. In this post, we\u2019ll explore how to create entity classes for a relational schema, focusing on best practices and solving common challenges such as composite keys.\\n\\n\x3c!-- truncate --\x3e\\n\\n---\\n\\n\\n## **Schema Overview**\\n\\nConsider the following relational database schema:\\n\\n- **Users** (`id`, `name`, `email`)\\n- **Posts** (`id`, `user_id`, `title`, `content`, `date`)\\n- **Comments** (`post_id`, `user_id`, `comment`, `date`)\\n\\nHere\u2019s what each table represents:\\n- **Users**: Stores user information.\\n- **Posts**: Represents content posted by users, linked to the `users` table.\\n- **Comments**: Stores user comments on posts, linked to both `posts` and `users`.\\n\\n---\\n\\n## **Creating Entity Classes**\\n\\n### **Step 1: The `User` Entity**\\n\\nThe `User` entity represents the `users` table. It has a one-to-many relationship with both `posts` and `comments`.\\n\\n```java\\nimport jakarta.persistence.*;\\nimport java.util.List;\\n\\n@Entity\\n@Table(name = \\"users\\")\\npublic class User {\\n    @Id\\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\\n    private Long id;\\n\\n    private String name;\\n    private String email;\\n\\n    @OneToMany(mappedBy = \\"user\\", cascade = CascadeType.ALL, orphanRemoval = true)\\n    private List<Post> posts;\\n\\n    @OneToMany(mappedBy = \\"user\\", cascade = CascadeType.ALL, orphanRemoval = true)\\n    private List<Comment> comments;\\n\\n    // Getters and Setters\\n}\\n```\\n\\n### **Step 2: The `Post` Entity**\\n\\nThe `Post` entity maps the `posts` table. It has a `ManyToOne` relationship with `User` and a `OneToMany` relationship with `Comment`.\\n\\n```java\\nimport jakarta.persistence.*;\\nimport java.time.LocalDate;\\nimport java.util.List;\\n\\n@Entity\\n@Table(name = \\"posts\\")\\npublic class Post {\\n    @Id\\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\\n    private Long id;\\n\\n    @ManyToOne\\n    @JoinColumn(name = \\"user_id\\", nullable = false)\\n    private User user;\\n\\n    private String title;\\n    private String content;\\n    private LocalDate date;\\n\\n    @OneToMany(mappedBy = \\"post\\", cascade = CascadeType.ALL, orphanRemoval = true)\\n    private List<Comment> comments;\\n\\n    // Getters and Setters\\n}\\n```\\n\\n### **Step 3: The `Comment` Entity with a Composite Key**\\n\\nUnlike the `User` and `Post` entities, the `Comment` entity uses a composite primary key (`post_id`, `user_id`). This eliminates the need for a separate `id` field. Here\u2019s how to implement it:\\n\\n#### **Composite Key Class (`CommentId`)**\\n\\n```java\\nimport jakarta.persistence.Embeddable;\\nimport java.io.Serializable;\\nimport java.util.Objects;\\n\\n@Embeddable\\npublic class CommentId implements Serializable {\\n\\n    private Long postId;\\n\\n    private Long userId;\\n\\n    // Default constructor\\n    public CommentId() {}\\n\\n    public CommentId(Long postId, Long userId) {\\n        this.postId = postId;\\n        this.userId = userId;\\n    }\\n\\n    // Getters and Setters\\n    \\n\\n    // Override equals() and hashCode()\\n    @Override\\n    public boolean equals(Object o) {\\n        if (this == o) return true;\\n        if (o == null || getClass() != o.getClass()) return false;\\n        CommentId that = (CommentId) o;\\n        return Objects.equals(postId, that.postId) &&\\n               Objects.equals(userId, that.userId);\\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return Objects.hash(postId, userId);\\n    }\\n}\\n```\\n\\n#### **The `Comment` Entity**\\n\\n```java\\nimport jakarta.persistence.*;\\nimport java.time.LocalDate;\\n\\n@Entity\\n@Table(name = \\"comments\\")\\npublic class Comment {\\n    @EmbeddedId\\n    private CommentId id;\\n\\n    @ManyToOne\\n    @MapsId(\\"postId\\")\\n    @JoinColumn(name = \\"post_id\\", nullable = false)\\n    private Post post;\\n\\n    @ManyToOne\\n    @MapsId(\\"userId\\")\\n    @JoinColumn(name = \\"user_id\\", nullable = false)\\n    private User user;\\n\\n    private String comment;\\n    private LocalDate date;\\n\\n    // Getters and Setters\\n}\\n```\\n\\n---\\n\\n## **Key Takeaways**\\n\\n1. **Relationships**:\\n   - Use `@ManyToOne` and `@OneToMany` for parent-child relationships.\\n   - For bidirectional relationships, annotate the owning side.\\n\\n2. **Composite Keys**:\\n   - Define a separate `@Embeddable` class to represent composite keys.\\n   - Use `@EmbeddedId` in the entity and `@MapsId` to map foreign keys.\\n\\n3. **Database Integrity**:\\n   - Ensure relationships are managed correctly with cascading and orphan removal policies.\\n\\n4. **Best Practices**:\\n   - Always override `equals()` and `hashCode()` in composite key classes.\\n   - Keep your entities simple and focused on mapping rather than business logic.\\n\\n---\\n\\n## **Conclusion**\\n\\nBy following these steps, you can create robust JPA entity classes tailored to your database schema. Whether you\'re using simple primary keys or composite keys, understanding JPA annotations and relationships is key to building scalable applications."},{"id":"what-is-spring-boot-starters","metadata":{"permalink":"/blog/what-is-spring-boot-starters","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2024-11-16-what-spring-boot-starters/index.md","source":"@site/blog/2024-11-16-what-spring-boot-starters/index.md","title":"What is Spring Boot Starter","description":"Introduction","date":"2024-11-16T00:00:00.000Z","tags":[{"inline":false,"label":"Spring","permalink":"/blog/tags/spring","description":"Spring Boot"},{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"Java"}],"readingTime":1.955,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"what-is-spring-boot-starters","title":"What is Spring Boot Starter","authors":["vijay"],"tags":["spring","java"]},"unlisted":false,"prevItem":{"title":"How to Create Entity Classes for Relational Tables","permalink":"/blog/how-to-create-entity-classes-for-relational-tables"},"nextItem":{"title":"What is Spring Framework","permalink":"/blog/what-is-spring-and-spring-boot"}},"content":"## Introduction\\n\\nSpring Boot starters are predefined templates or dependencies that simplify the process of setting up a Spring Boot application. They eliminate the need to manually define numerous dependencies, ensuring compatibility and reducing configuration effort.\\n\\nHere\u2019s a list of commonly used Spring Boot starters and their purposes:\\n\\n\x3c!-- truncate --\x3e\\n---\\n\\n## **Core Starters**\\n1. **spring-boot-starter**  \\n   - Base starter for any Spring Boot application.  \\n   - Includes essential dependencies like Spring Core, Logging, etc.\\n\\n2. **spring-boot-starter-test**  \\n   - Starter for testing Spring Boot applications.  \\n   - Includes JUnit, Mockito, Spring Test, and AssertJ.\\n\\n---\\n\\n## **Web Development**\\n3. **spring-boot-starter-web**  \\n   - For building RESTful web applications.  \\n   - Includes Spring MVC, Jackson (for JSON processing), and embedded Tomcat.\\n\\n4. **spring-boot-starter-webflux**  \\n   - For reactive web applications using Project Reactor and WebFlux.  \\n   - Includes Netty or Tomcat for reactive web servers.\\n\\n---\\n\\n## **Data Access**\\n5. **spring-boot-starter-data-jpa**  \\n   - For JPA-based repositories and Hibernate ORM.  \\n   - Includes Spring Data JPA and an H2 database.\\n\\n6. **spring-boot-starter-data-mongodb**  \\n   - For MongoDB support.  \\n   - Includes Spring Data MongoDB.\\n\\n7. **spring-boot-starter-data-redis**  \\n   - For Redis data access.  \\n   - Includes Spring Data Redis and Lettuce.\\n\\n8. **spring-boot-starter-jdbc**  \\n   - For traditional JDBC-based database access.  \\n   - Includes Spring JDBC and DataSource support.\\n\\n---\\n\\n## **Security**\\n9. **spring-boot-starter-security**  \\n   - Adds Spring Security to your application.  \\n   - Supports authentication, authorization, and secure login mechanisms.\\n\\n---\\n\\n## **Messaging**\\n10. **spring-boot-starter-amqp**  \\n    - For RabbitMQ messaging.  \\n    - Includes Spring AMQP.\\n\\n11. **spring-boot-starter-activemq**  \\n    - For ActiveMQ messaging.\\n\\n12. **spring-boot-starter-kafka**  \\n    - For Apache Kafka messaging.\\n\\n---\\n\\n## **Cloud & Configuration**\\n13. **spring-boot-starter-actuator**  \\n    - Adds production-ready features like monitoring and metrics endpoints.\\n\\n14. **spring-boot-starter-cloud-config**  \\n    - For using Spring Cloud Config to manage configuration across environments.\\n\\n---\\n\\n## **Template Engines**\\n15. **spring-boot-starter-thymeleaf**  \\n    - For server-side rendering with Thymeleaf templates.\\n\\n16. **spring-boot-starter-freemarker**  \\n    - For server-side rendering with FreeMarker templates.\\n\\n---\\n\\n## **Others**\\n17. **spring-boot-starter-batch**  \\n    - For batch processing using Spring Batch.\\n\\n18. **spring-boot-starter-cache**  \\n    - Adds caching capabilities to your application.\\n\\n19. **spring-boot-starter-mail**  \\n    - For sending emails.\\n\\n20. **spring-boot-starter-validation**  \\n    - For data validation using Hibernate Validator.\\n\\n21. **spring-boot-starter-aop**  \\n    - Adds support for aspect-oriented programming using Spring AOP.\\n\\n---\\n\\n## Why Use Spring Boot Starters?\\n- **Reduced Configuration:** Predefined dependencies ensure compatibility.\\n- **Improved Productivity:** Faster setup time for new projects.\\n- **Focused Development:** You can focus on business logic instead of boilerplate code.\\n\\nWould you like me to structure this further or add examples for specific starters?"},{"id":"what-is-spring-and-spring-boot","metadata":{"permalink":"/blog/what-is-spring-and-spring-boot","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2024-11-14-what-is-spring-and-spring-boot/index.md","source":"@site/blog/2024-11-14-what-is-spring-and-spring-boot/index.md","title":"What is Spring Framework","description":"Spring Framework","date":"2024-11-14T00:00:00.000Z","tags":[{"inline":false,"label":"Spring","permalink":"/blog/tags/spring","description":"Spring Boot"},{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"Java"}],"readingTime":2.175,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"what-is-spring-and-spring-boot","title":"What is Spring Framework","authors":["vijay"],"tags":["spring","java"]},"unlisted":false,"prevItem":{"title":"What is Spring Boot Starter","permalink":"/blog/what-is-spring-boot-starters"},"nextItem":{"title":"When to choose MySql vs PostgreSql relation databse","permalink":"/blog/When-to-choose-MySql-vs-PostgreSql-relation-databse"}},"content":"## Spring Framework\\n\\nThe **Spring Framework** is a comprehensive and widely-used framework in the Java ecosystem for building enterprise-level applications. Its core feature is **dependency injection (DI)**, which helps with the loose coupling of components, making applications easier to manage and test. Spring provides many modules for various tasks, like web development, data access, messaging, and more, making it highly modular and suitable for a variety of projects.\\n\\n\x3c!-- truncate --\x3e\\n\\n**Key Features of Spring Framework**:\\n1. **Dependency Injection (DI)** and **Inversion of Control (IoC)**: Simplifies object creation and dependency handling.\\n2. **Aspect-Oriented Programming (AOP)**: Adds cross-cutting concerns like logging and transaction management.\\n3. **Data Access**: Supports integration with JDBC, JPA, Hibernate, and other data access technologies.\\n4. **Web Development**: Spring MVC (Model-View-Controller) module helps in building web applications.\\n5. **Modularity**: Has different modules like Spring Core, Spring Data, Spring Web, Spring Security, etc.\\n\\n## Spring Boot\\n\\n**Spring Boot** is a project built on top of the Spring Framework that aims to simplify the process of creating stand-alone, production-ready Spring applications. It abstracts away much of the configuration and boilerplate code that is traditionally associated with setting up a Spring project. With Spring Boot, you can get a Spring application up and running with minimal setup.\\n\\n**Key Features of Spring Boot**:\\n1. **Auto-Configuration**: Automatically configures your application based on the dependencies you include in the project.\\n2. **Standalone Applications**: Allows you to create standalone applications that run with `java -jar` commands.\\n3. **Embedded Servers**: Comes with embedded servers (like Tomcat, Jetty), so you don\u2019t need to deploy the application to an external server.\\n4. **Spring Boot Starters**: Simplifies dependency management by providing pre-configured sets of libraries (Starters) for different use cases (e.g., `spring-boot-starter-web` for web applications).\\n5. **Production-Ready Features**: Provides metrics, health checks, and externalized configuration to help in production management.\\n\\n## Relationship Between Spring Framework and Spring Boot\\n\\n- **Spring Framework** is the foundation of Spring-based projects and includes all the core functionalities, like DI, AOP, and MVC. Spring Boot, however, is built on top of the Spring Framework to simplify the process of developing Spring applications.\\n- **Spring Boot** is not a replacement but an enhancement for the Spring Framework, offering tools and defaults that help developers to rapidly create applications without writing too much configuration.\\n- **Spring Boot** leverages the components of the Spring Framework but adds its layer of abstraction, allowing for quick setup and ready-to-use defaults, especially useful for microservices and RESTful APIs.\\n\\nIn summary, **Spring Framework** provides the core infrastructure, while **Spring Boot** makes it easier to create applications with Spring by reducing configuration and simplifying the setup process."},{"id":"When-to-choose-MySql-vs-PostgreSql-relation-databse","metadata":{"permalink":"/blog/When-to-choose-MySql-vs-PostgreSql-relation-databse","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2024-09-26-mysql-vs-postgresql/index.md","source":"@site/blog/2024-09-26-mysql-vs-postgresql/index.md","title":"When to choose MySql vs PostgreSql relation databse","description":"Choosing between MySQL and PostgreSQL depends on your project requirements, data complexity, and specific use cases. Here\u2019s a breakdown of when to choose each:","date":"2024-09-26T00:00:00.000Z","tags":[{"inline":false,"label":"Database","permalink":"/blog/tags/database","description":"Database"}],"readingTime":1.635,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"When-to-choose-MySql-vs-PostgreSql-relation-databse","title":"When to choose MySql vs PostgreSql relation databse","authors":["vijay"],"tags":["database"]},"unlisted":false,"prevItem":{"title":"What is Spring Framework","permalink":"/blog/what-is-spring-and-spring-boot"},"nextItem":{"title":"Instrumenting Spring Boot Applications with OpenTelemetry (Without Java Agent)","permalink":"/blog/Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent"}},"content":"Choosing between MySQL and PostgreSQL depends on your project requirements, data complexity, and specific use cases. Here\u2019s a breakdown of when to choose each:\\n\\n## **When to Choose MySQL**\\n\\n1. **Simplicity and Ease of Use**: Ideal for beginners or small applications where quick setup and ease of management are priorities.\\n\x3c!-- truncate --\x3e\\n\\n2. **Read-Heavy Workloads**: Best suited for applications with high read-to-write ratios, such as content management systems or websites with static data.\\n\\n3. **Speed**: MySQL can outperform PostgreSQL in certain read-heavy scenarios due to its optimization for fast reads.\\n\\n4. **Web Applications**: Commonly used in web applications, especially with PHP and frameworks like WordPress.\\n\\n5. **Replication Needs**: Offers simpler replication features, making it a good choice for applications requiring master-slave replication.\\n\\n## **When to Choose PostgreSQL**\\n\\n1. **Complex Queries**: Preferred for applications requiring complex queries, advanced data types, and powerful analytical capabilities.\\n\\n2. **Data Integrity and Compliance**: Stronger support for ACID compliance, making it suitable for applications that demand data integrity, such as financial systems.\\n\\n3. **Advanced Features**: Supports advanced features like full-text search, JSONB data type, and GIS capabilities (PostGIS).\\n\\n4. **Concurrency**: Better at handling concurrent transactions due to its MVCC (Multiversion Concurrency Control) architecture.\\n\\n5. **Extensibility**: Allows for custom data types, functions, and operators, making it highly customizable for specialized applications.\\n\\n6. **Geospatial Data**: Excellent choice if you need to handle geospatial data with complex queries.\\n\\n## **Considerations for Both**\\n\\n- **Community and Support**: Both databases have strong communities and plenty of resources available.\\n- **Hosting**: Check if your hosting provider supports the database of your choice and offers optimized configurations.\\n- **Migration Plans**: If you plan to scale your application, consider how easy it is to migrate from one database to another.\\n\\n## **Conclusion**\\n\\n- Choose **MySQL** for simpler, read-heavy applications with less complexity.\\n- Opt for **PostgreSQL** when you need advanced features, complex queries, and robust data integrity.\\n\\nEvaluate your specific use case and performance requirements to make the best choice!"},{"id":"Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent","metadata":{"permalink":"/blog/Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2024-08-14-Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent/index.md","source":"@site/blog/2024-08-14-Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent/index.md","title":"Instrumenting Spring Boot Applications with OpenTelemetry (Without Java Agent)","description":"Introduction","date":"2024-08-14T00:00:00.000Z","tags":[{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"Java"}],"readingTime":2.235,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent","title":"Instrumenting Spring Boot Applications with OpenTelemetry (Without Java Agent)","authors":["vijay"],"tags":["java"]},"unlisted":false,"prevItem":{"title":"When to choose MySql vs PostgreSql relation databse","permalink":"/blog/When-to-choose-MySql-vs-PostgreSql-relation-databse"},"nextItem":{"title":"What Is Stream In java","permalink":"/blog/what-is-stream-in-java"}},"content":"## **Introduction**\\n\\nIn modern distributed systems, observability is crucial for monitoring application performance and troubleshooting issues. OpenTelemetry (OTel) is a powerful tool for collecting telemetry data such as traces, metrics, and logs. In this guide, we\'ll walk through how to instrument a Spring Boot application with OpenTelemetry without using the Java agent, and how to export the telemetry data to Jaeger using Docker.\\n\\n\x3c!-- truncate --\x3e\\n\\n## **Step 1: Setting Up OpenTelemetry in Spring Boot**\\n\\nFirst, you\'ll need to add the necessary OpenTelemetry dependencies to your Spring Boot project. Here\'s how to do it with Gradle:\\n\\n```groovy\\ndependencies {\\n    implementation(platform(\\"io.opentelemetry.instrumentation:opentelemetry-instrumentation-bom:2.6.0\\"))\\n    implementation(\\"io.opentelemetry.instrumentation:opentelemetry-spring-boot-starter\\")\\n}\\n```\\n\\nThese dependencies bring in the OpenTelemetry SDK and the Spring Boot starter, which helps in auto-configuring the instrumentation of your application.\\n\\n## **Step 2: Configuring OpenTelemetry in Spring Boot**\\n\\nNext, configure OpenTelemetry in your `application.yml` (or `application.properties`) to define how traces are exported and propagated:\\n\\n```yaml\\notel:\\n  traces:\\n    exporter: otlp\\n  exporter:\\n    otlp:\\n      endpoint: http://localhost:4317\\n      protocol: grpc\\n  propagators:\\n    - tracecontext\\n  resource:\\n    attributes:\\n      deployment.environment: dev\\n      service:\\n        name: webflux\\n        namespace: spring\\n```\\n\\nHere\u2019s what each part does:\\n\\n- **traces.exporter.otlp**: Specifies the OTLP (OpenTelemetry Protocol) as the exporter.\\n- **exporter.otlp.endpoint**: The endpoint where the traces will be sent.\\n- **propagators**: Configures the trace context propagation.\\n- **resource.attributes**: Adds metadata like environment and service name to the traces.\\n\\n## **Step 3: Running Jaeger with Docker Compose**\\n\\nTo visualize the traces, you\'ll need a tool like Jaeger. Here\u2019s a `docker-compose.yml` setup that runs Jaeger with Elasticsearch as the storage backend:\\n\\n```yaml\\nversion: \\"3.7\\"\\n\\nservices:\\n  jaeger-collector:\\n    image: jaegertracing/jaeger-collector:1.40\\n    environment:\\n      - COLLECTOR_OTLP_ENABLED=true # Enable OTLP endpoint\\n      - SPAN_STORAGE_TYPE=elasticsearch\\n      - ES_SERVER_URLS=http://elasticsearch:9200\\n    ports:\\n      - \\"14250:14250\\" # OTLP gRPC\\n      - \\"14268:14268\\" # Jaeger HTTP Thrift\\n      - \\"4317:4317\\" # OTLP gRPC for traces\\n      - \\"4318:4318\\" # OTLP HTTP for traces\\n    depends_on:\\n      - elasticsearch\\n    networks:\\n      - jaeger-network\\n\\n  jaeger-query:\\n    image: jaegertracing/jaeger-query:1.40\\n    environment:\\n      - SPAN_STORAGE_TYPE=elasticsearch\\n      - ES_SERVER_URLS=http://elasticsearch:9200\\n    ports:\\n      - \\"16686:16686\\" # Jaeger UI\\n    depends_on:\\n      - jaeger-collector\\n    networks:\\n      - jaeger-network\\n\\n  elasticsearch:\\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.10.2\\n    environment:\\n      - discovery.type=single-node\\n    ports:\\n      - \\"9200:9200\\"\\n    networks:\\n      - jaeger-network\\n\\nnetworks:\\n  jaeger-network:\\n    driver: bridge\\n```\\n\\nThis setup creates three services:\\n\\n- **Jaeger Collector**: Collects traces from your application.\\n- **Jaeger Query**: Provides a UI to view and query traces.\\n- **Elasticsearch**: Stores the trace data.\\n\\n## **Step 4: Testing the Setup**\\n\\nOnce everything is configured, start your application and the Docker Compose setup. Generate some traffic in your application to produce traces. You should see the traces appear in the Jaeger UI at `http://localhost:16686`.\\n\\n## **Conclusion**\\n\\nBy following these steps, you\'ve successfully instrumented your Spring Boot application with OpenTelemetry, configured it to export traces to Jaeger, and visualized the traces without using the OpenTelemetry Java agent. This approach offers flexibility and control over how your application is instrumented."},{"id":"what-is-stream-in-java","metadata":{"permalink":"/blog/what-is-stream-in-java","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2024-06-15-what-is-stream-in-java/index.md","source":"@site/blog/2024-06-15-what-is-stream-in-java/index.md","title":"What Is Stream In java","description":"Introduction","date":"2024-06-15T00:00:00.000Z","tags":[{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"Java"}],"readingTime":2.59,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"what-is-stream-in-java","title":"What Is Stream In java","authors":["vijay"],"tags":["java"]},"unlisted":false,"prevItem":{"title":"Instrumenting Spring Boot Applications with OpenTelemetry (Without Java Agent)","permalink":"/blog/Instrumenting-Spring-Boot-Applications-with-OpenTelemetry-Without-Java-Agent"},"nextItem":{"title":"Build Docker Image Using Jib","permalink":"/blog/build-docker-image-using-jib"}},"content":"## Introduction\\n\\nA sequence of elements in Java that supports several methods that can be pipelined to achieve a desired outcome is called a stream. Originally included in Java 8 as a component of the java.util.stream package, streams are a part of the Java Collections Framework. They are made to manipulate data declaratively, much like SQL does with information kept in tables.\\n\\n\x3c!--truncate--\x3e\\n\\n## Key Characteristics of Streams\\n\\n1. **Sequence of Elements**: A stream provides a sequence of elements, where each element is processed one at a time.\\n2. **Functional in Nature**: Operations on a stream are performed using a functional programming approach, allowing for concise and readable code.\\n3. **Lazy Evaluation**: Stream operations are lazy; they are not executed until a terminal operation is invoked. This allows for optimization and efficient processing.\\n4. **Parallel Processing**: Streams can be easily parallelized, making it simple to perform operations on multiple elements concurrently.\\n\\n## Types of Stream Operations\\n\\nThere are two main types of stream operations: intermediate and terminal operations.\\n\\n**Intermediate Operations**:\\n- These operations return a new stream and are lazy, meaning they do not trigger any processing until a terminal operation is invoked.\\n- Examples include `filter()`, `map()`, `flatMap()`, `distinct()`, `sorted()`, and `limit()`.\\n\\n**Terminal Operations**:\\n- These operations trigger the actual processing of the stream and produce a result or a side-effect.\\n- Examples include `forEach()`, `collect()`, `reduce()`, `count()`, `findFirst()`, and `allMatch()`.\\n\\n## Creating Streams\\n\\nStreams can be created from various data sources such as collections, arrays, and I/O channels. Here are some examples:\\n\\n**From Collections**:\\n```java\\nList<String> list = Arrays.asList(\\"a\\", \\"b\\", \\"c\\");\\nStream<String> stream = list.stream();\\n```\\n\\n**From Arrays**:\\n```java\\nString[] array = {\\"a\\", \\"b\\", \\"c\\"};\\nStream<String> stream = Arrays.stream(array);\\n```\\n\\n**From Lines of a File**:\\n```java\\nStream<String> lines = Files.lines(Paths.get(\\"file.txt\\"));\\n```\\n\\n**From Values**:\\n```java\\nStream<String> stream = Stream.of(\\"a\\", \\"b\\", \\"c\\");\\n```\\n\\n## Common Stream Operations\\n\\nHere are some common operations performed on streams:\\n\\n**Filtering**:\\n```java\\nList<String> filteredList = list.stream()\\n                                .filter(s -> s.startsWith(\\"a\\"))\\n                                .collect(Collectors.toList());\\n```\\n\\n**Mapping**:\\n```java\\nList<Integer> lengths = list.stream()\\n                            .map(String::length)\\n                            .collect(Collectors.toList());\\n```\\n\\n**Reducing**:\\n```java\\nOptional<String> concatenated = list.stream()\\n                                    .reduce((s1, s2) -> s1 + s2);\\n```\\n\\n**Collecting**:\\n```java\\nList<String> collected = list.stream()\\n                             .sorted()\\n                             .collect(Collectors.toList());\\n```\\n\\n**Parallel Streams**:\\n```java\\nList<String> parallelList = list.parallelStream()\\n                                .filter(s -> s.startsWith(\\"a\\"))\\n                                .collect(Collectors.toList());\\n```\\n\\n## Example Usage\\n\\nHere\'s a complete example that demonstrates the use of various stream operations:\\n\\n```java\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.stream.Collectors;\\n\\npublic class StreamExample {\\n    public static void main(String[] args) {\\n        List<String> names = Arrays.asList(\\"Ram\\", \\"Krishna\\", \\"Chanakya\\", \\"Patel\\", \\"Lakshman\\");\\n\\n        // Convert all names to uppercase and filter names that start with \'A\'\\n        List<String> result = names.stream()\\n                                   .map(String::toUpperCase)\\n                                   .filter(name -> name.startsWith(\\"R\\"))\\n                                   .collect(Collectors.toList());\\n\\n        // Print the result\\n        result.forEach(System.out::println);\\n    }\\n}\\n```\\n\\nIn this example, the `names` list is converted to a stream, each name is mapped to its uppercase form, filtered to retain names starting with `R`, and then collected into a new list, which is printed to the console.\\n\\n## Conclusion\\n\\nStreams in Java provide a powerful and flexible way to perform complex data processing tasks in a declarative and efficient manner. They enable functional-style operations on collections of elements, making it easier to write concise and readable code."},{"id":"build-docker-image-using-jib","metadata":{"permalink":"/blog/build-docker-image-using-jib","editUrl":"https://github.com/vijaypatidar/my-portfolio/tree/main/blog/2024-06-08-build-docker-image-using-jib/index.md","source":"@site/blog/2024-06-08-build-docker-image-using-jib/index.md","title":"Build Docker Image Using Jib","description":"Docker Build","date":"2024-06-08T00:00:00.000Z","tags":[{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"Java"},{"inline":false,"label":"Spring","permalink":"/blog/tags/spring","description":"Spring Boot"}],"readingTime":1.89,"hasTruncateMarker":true,"authors":[{"name":"Vijay Patidar","title":"Fullstack Software Engineer","url":"https://github.com/vijaypatidar","imageURL":"https://github.com/vijaypatidar.png","key":"vijay","page":null}],"frontMatter":{"slug":"build-docker-image-using-jib","title":"Build Docker Image Using Jib","authors":["vijay"],"tags":["java","spring"]},"unlisted":false,"prevItem":{"title":"What Is Stream In java","permalink":"/blog/what-is-stream-in-java"}},"content":"![Docker Build](./docker-build.png)\\n\\n## Overview\\n\\nThis blog post introduces Jib, a powerful tool for building optimized Docker images for Java applications. Jib stands out by eliminating the need for a Docker daemon and expertise in Docker best practices, making it a convenient option for developers. Integrated as a plugin in Gradle or Maven projects, Jib simplifies the process of containerizing Java applications.\\n\\n\x3c!--truncate--\x3e\\n\\n## What is Jib?\\n\\nJib builds optimized Docker images for your Java applications without a Docker daemon or deep mastery of Docker best practices.\\nYou can use it as a plugin in your Gradle or Maven project.\\n\\n## Let\'s configure gradle to use Jib\\n\\nJib is used as a plugin, so we need to update the `build.gradle` file. We simply need to add the Jib plugin and define the Jib configuration block.\\n\\n```gradle title=\\"build.gradle\\"\\nplugins {\\n    . . .\\n    id \'com.google.cloud.tools.jib\' version \'3.1.1\'\\n}\\n\\n. . .\\n\\njib {\\n    from {\\n        image = \\"amazoncorretto:11\\"\\n    }\\n    to {\\n        image = \\"docker.io/vijaypatidar31/webflux\\"\\n        tags = [\\"latest\\", version]\\n    }\\n    container {\\n        mainClass = \\"com.vkpapps.demo.CoolSpringWebfluxApplication\\"\\n        jvmFlags = []\\n        ports = [\\"443\\"]\\n    }\\n}\\n```\\n\\n## Build And Publish Image To Docker Registry\\n\\nAfter configuring the jib block, you can run a gradle task to build and publish an image to the Docker registry (gradle jib).\\n\\n## Benefits\\n\\n- Using Jib over a traditional Dockerfile for building and packaging Java applications offers several benefits:\\n- Simplified Configuration: Integrates with Gradle/Maven, eliminating the need for a separate Dockerfile.\\n- Faster Builds: Uses advanced caching mechanisms, reducing the need to rebuild unchanged layers.\\n- Reproducible Builds: Ensures builds are reproducible by isolating the build environment from the runtime environment.\\n- No Docker Daemon Required: Builds Docker images without requiring a Docker daemon, suitable for CI/CD pipelines or restricted environments.\\n- Automatic Base Image Updates: This can automatically pull the latest base image, ensuring the use of up-to-date images with the latest security patches.\\n- Layered Image Construction: Automatically separates the application into layers, optimizing the build and pushing process.\\n- Integration with Container Registries: Seamlessly integrates with popular container registries, making it easy to push images directly from your build tool.\\n- Advanced Configuration Options: Provides options for customizing the image build, such as specifying entry points, environment variables, JVM flags, and exposed ports."}]}}')}}]);